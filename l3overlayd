#!/usr/bin/python3
#
# Copyright (c) 2016 Catalyst.net Ltd
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import argparse
import configparser
import errno
import hashlib
import ipaddress
import logging
import math
import os
import re
import shutil
import signal
import socket
import stat
import subprocess
import sys
import time

from distutils.spawn import find_executable

from jinja2 import Environment
from jinja2 import FileSystemLoader

from pyroute2 import IPDB
from pyroute2 import netns
from pyroute2 import NetNS

class OverlayDaemon(object):


    def __init__(self, template_dir, lib_dir, log_file, global_conf, fwbuilder_script_dir, overlay_paths):

        # Directory which stores configuration templates.
        self.template_dir = template_dir

        # Directory for l3overlayd state information.
        self.lib_dir = lib_dir

        # Daemon log file.
        self.log_file = log_file

        # Filepath for the global configuration file.
        self.global_conf = global_conf

        # Directory for fwbuilder scripts.
        self.fwbuilder_script_dir = fwbuilder_script_dir

        # Filepaths to the overlay configuration files.
        self.overlay_paths = tuple(overlay_paths)

        # Initial state for an OverlayDaemon is stopped, and NOT shut down.
        self.stopped = True
        self.shut_down = False

        # Root namespace IPDB. Ideally, this would be loaded in config_load(),
        # but IPDB's weren't designed to be started and stopped more than once
        # in an instance.
        self.ipdb = IPDB()

        # OverlayDaemon starting routine.
        self.start()


    def start_config(self):
        """
        Load the runtime configuration for this OverlayDaemon.
        """

        # Load the global configuration file.
        if os.path.exists(self.global_conf):
            config = configparser.ConfigParser()
            config.read(self.global_conf)

            self.config_env = Environment(
                trim_blocks=True,
                loader=FileSystemLoader(template_dir),
            )
        else:
            config = {'global': {}}

        # Logging level.
        if 'logging-level' in config['global']:
            self.logging_level = Util.enum_get(
                config['global']['logging-level'],
                [ 'NOSET', 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL' ],
            )
        else: 
            self.logging_level = logging.INFO

        # Check whether or not to use IPsec.
        if 'use-ipsec' in config['global']:
            self.use_ipsec = Util.boolean_get(config['global']['use-ipsec'])
        else:
            self.use_ipsec = False

        # IPsec PSK, to be configured onto all tunnels.
        self.ipsec_psk = Util.hex_get_string(config['global']['ipsec-psk'], min=6, max=64) if self.use_ipsec == True else None

        # Determine whether or not to take over control of IPsec. Read the
        # README for more information on how this option works.
        if 'use-ipsec' in config['global']:
            self.ipsec_manage = Util.boolean_get(config['global']['ipsec-manage']) if 'ipsec-manage' in config['global'] else True
        else:
            self.ipsec_manage = False

        #
        # Find external files needed in overlay configuration.
        #

        # Used to generate the BIRD routing daemon configurations.
        self.bird_config_template = self.config_env.get_template('bird.conf')

        # Used to generate the IPsec tunnel configuration.
        self.ipsec_config_template = self.config_env.get_template('ipsec.conf')
        self.ipsec_secrets_template = self.config_env.get_template('ipsec.secrets')

        #
        # Runtime data structures and objects.
        #

        # Used by Overlay.interface_name() to store the interface names already
        # generated by itself, so it can generate a unique one in the next run.
        self.interface_names = []

        # List of mesh tunnel links that have been made, and how many times
        # they have been made (by allowing duplicates in the list).
        #
        # Used by Overlay.gre_key() to store the amount of times a specific
        # link has been used to create a GRE tunnel, so it can return a unique
        # key for the next one.
        #
        # Also used by start_ipsec() and stop_ipsec() to generate the IPsec
        # tunnels that are used to encapsulate the GRE tunnels.
        self.mesh_tunnels = []

        # List of overlays.
        self.overlays = []

        # IPsec directories and files.
        if self.use_ipsec == True:
            if self.ipsec_manage == True:
                self.ipsec_config_dir = os.path.join(Util.path_root(), "etc")
                self.ipsec_config_file = os.path.join(self.ipsec_config_dir, "ipsec.conf")
            else:
                self.ipsec_config_dir = os.path.join(Util.path_root(), "etc", "ipsec.d")
                self.ipsec_config_file = os.path.join(self.ipsec_config_dir, "l3overlay.conf")

            self.ipsec_secrets_dir = os.path.join(Util.path_root(), "etc")

            self.ipsec_secrets_stub_file = os.path.join(self.ipsec_secrets_dir, "ipsec.secrets")
            self.ipsec_secrets_file = os.path.join(self.ipsec_secrets_dir, "ipsec.l3overlay.secrets")


    def start_logging(self):
        """
        Configure the logging system.
        """

        logging.basicConfig(
            level=self.logging_level,
            handlers=[
                logging.FileHandler(self.log_file),
                logging.StreamHandler(),
            ],
        )


    def start(self):
        """
        Start this OverlayDaemon, and all of its configured overlays.
        """

        if self.shut_down == True:
            raise Exception("OverlayDaemon permanently shut down, cannot start again")

        if self.stopped == False:
            return

        self.stopped = False

        # Load the runtime configuration data.
        self.start_config()

        # Configure the logging system.
        self.start_logging()

        # This is the point where building the OverlayDaemon starts.
        logging.info("Starting daemon...")

        # Create the runtime directories.
        self.start_directories()

        # Start all of the configured overlays.
        for overlay_path in overlay_paths:
            self.overlays.append(Overlay(self, overlay_path))

        # Start the IPsec tunnels for the overlays.
        self.start_ipsec()

        logging.info("Started.")


    def start_directories(self):
        """
        Create the runtime directories for this OverlayDaemon, securely, with
        the correct umask.
        """

        # Set the umask so that any files that this OverlayDaemon creates, will
        # only be readable and writable by itself.
        logging.info("setting up file and directory handling")

        logging.info("setting umask")
        os.umask(
            stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP |
            stat.S_IROTH | stat.S_IWOTH | stat.S_IXOTH
        )

        # Create directories.
        logging.info("creating %s" % self.lib_dir)
        Util.directory_create(self.lib_dir)

        logging.info("finished setting up file and directory handling")


    def start_ipsec(self):
        """
        Configure and start the strongSwan IPsec tunnel daemon, if enabled.
        """

        if self.use_ipsec == False:
            return

        logging.debug("setting up IPsec daemon management")

        # Create the IPsec config directory.
        logging.debug("creating IPsec configuration directory")
        Util.directory_create(self.ipsec_config_dir)

        # Start doing everything needed to start IPsec.
        logging.debug("configuring ipsec")

        # Save the IPsec configuration.
        logging.debug("saving ipsec configuration to disk")

        f = open(self.ipsec_config_file, 'w')
        f.write(self.ipsec_config_template.render(
            file=self.ipsec_config_file,
            mesh_tunnels=self.mesh_tunnels,
        ))
        f.close()

        # Create the directory where the IPsec secrets are stored.
        logging.debug("creating IPsec secrets directory")
        Util.directory_create(self.ipsec_secrets_dir)

        # This file includes the REAL IPsec secrets file which gets created
        # by l3overlay. Only gets created if ipsec_manage is true.
        if self.ipsec_manage == True:
            logging.debug("saving IPsec secrets stub file to disk")
            f = open(self.ipsec_secrets_stub_file, 'w')
            f.write("include %s\n" % self.ipsec_secrets_file)
            f.close()

        # Save the REAL ipsec.secrets.
        logging.debug("saving IPsec secrets file to disk")

        addresses = []

        for local, remote in self.mesh_tunnels:
            if local not in addresses:
                addresses.append(local)

            if remote not in addresses:
                addresses.append(remote)

        f = open(self.ipsec_secrets_file, 'w')
        f.write(self.ipsec_secrets_template.render(
            file=self.ipsec_secrets_file,
            addresses=addresses,
            secret=self.ipsec_psk,
        ))
        f.close()

        logging.debug("finished configuring ipsec")

        # Start IPsec, or, if it is already running, reload the configuration.
        try:
            ipsec = find_executable("ipsec")

            if ipsec is None:
                raise Exception("cannot find ipsec executable path")

            status = subprocess.call(
                [ipsec, "status"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )

            if status == 0:
                logging.debug("reloading IPsec")

                logging.debug("reloading IPsec secrets")
                subprocess.check_output(
                    [ipsec, "rereadsecrets"],
                    stderr=subprocess.STDOUT,
                )

                logging.debug("reloading IPsec configuration")
                subprocess.check_output(
                    [ipsec, "reload"],
                    stderr=subprocess.STDOUT,
                )

                logging.debug("finished reloading IPsec")
            elif status == 3:
                logging.debug("starting IPsec")

                subprocess.check_output(
                    [ipsec, "start"],
                    stderr=subprocess.STDOUT,
                )

                logging.debug("finished starting IPsec")
            else:
                raise Exception("unexpected return code for ipsec, status %i" % status)
        except subprocess.CalledProcessError as e:
            logging.error("error detected in process call:\n%s" % e.output.decode('UTF-8'))
            raise

        logging.debug("finished setting up IPsec daemon management")


    def stop(self):
        """
        Shut down all overlays in OverlayDaemon. Once an OverlayDaemon is
        stopped, it cannot be restarted.
        """

        if self.stopped == True:
            return

        self.stopped = True

        logging.info("Stopping daemon...")

        daemon.stop_ipsec()

        for overlay in self.overlays:
            overlay.stop()

        daemon.stop_directories()
        logging.info("Stopped.")


    def stop_directories(self):
        """
        Destroy the runtime directories.

        This should be fine, because at this point, there should be no required
        files in the runtime directories.
        """

        logging.info("removing %s" % self.lib_dir)
        shutil.rmtree(self.lib_dir)


    def stop_ipsec(self):
        """
        Stop the strongSwan IPsec tunnel daemon, and destroy the configuration,
        if enabled.
        """

        if self.use_ipsec == False:
            return

        logging.debug("stopping IPsec daemon management")

        logging.debug("removing IPsec configuration")
        os.remove(self.ipsec_config_file)

        if self.ipsec_manage == True:
            logging.debug("removing IPsec secrets stub file")
            os.remove(self.ipsec_secrets_stub_file)

        logging.debug("removing IPsec secrets file")
        os.remove(self.ipsec_secrets_file)

        try:
            ipsec = find_executable("ipsec")

            if ipsec is None:
                raise Exception("cannot find IPsec executable path")

            if self.ipsec_manage == True:
                # When we manage IPsec, it is safe to stop it completely.
                logging.debug("stopping IPsec")

                subprocess.check_output(
                    [ipsec, "stop"],
                    stderr=subprocess.STDOUT,
                )

                logging.debug("finished stopping IPsec")
            else:
                # When we don't, reload the configuration without the tunnels
                # configured, and shut down all of the tunnels.
                logging.debug("reloading IPsec")

                logging.debug("reloading IPsec secrets")
                subprocess.check_output(
                    [ipsec, "rereadsecrets"],
                    stderr=subprocess.STDOUT,
                )

                logging.debug("reloading IPsec configuration")
                subprocess.check_output(
                    [ipsec, "reload"],
                    stderr=subprocess.STDOUT,
                )

                for local, remote in self.mesh_tunnels:
                    logging.debug("shutting down IPsec tunnel %s-%s" % (str(local), str(remote)))
                    subprocess.check_output(
                        [ipsec, "down", "%s-%s" % (str(local), str(remote))],
                        stderr=subprocess.STDOUT,
                    )

                logging.debug("finished reloading IPsec")
        except subprocess.CalledProcessError as e:
            logging.error("error detected in process call:\n%s" % e.output.decode('UTF-8'))
            raise

        logging.debug("finished stopping IPsec daemon management")


    def shutdown(self):
        """
        Permanently shut down this OverlayDaemon.
        Only use if the program is exiting.
        """

        if self.shut_down == True:
            return

        self.shut_down = True

        logging.info("Shutting down daemon...")

        self.stop()
        daemon.ipdb.release()

        logging.info("Shut down.")


    def ipsec_config_add(self, key, value):
        """
        Add a variable to render to the IPsec configuration template.
        """

        logging.debug("adding variable %s to IPsec configuration" % key)
        self.ipsec_config[key] = value


class Overlay(object):


    def __init__(self, daemon, configuration_path):
        # Relevant global configuration.
        self.lib_dir = daemon.lib_dir
        self.fwbuilder_script_dir = daemon.fwbuilder_script_dir

        # Load the overlay configuration file.
        self.config = configparser.ConfigParser()
        self.config.read(configuration_path)

        # ipdb configuration. The network namespace ipdb gets loaded later.
        self.ipdb = None
        self.root_ipdb = daemon.ipdb

        # Check whether this overlay is enabled or not.
        if 'enabled' in self.config['overlay']:
            self.enabled = Util.boolean_get(self.config['overlay']['enabled'])
        else:
            self.enabled = True

        # Generate the list of nodes, sorted numerically.
        nodes_dict = {}

        for key in self.config['overlay'].keys():
            if key.startswith('node-'):
                nodes_dict[int(key.lstrip('node-'))] = tuple(self.config['overlay'][key].split())

        self.nodes = [nodes_dict[key] for key in sorted(nodes_dict.keys())]

        # Get the node dictionary for this node from the list of nodes.
        self.this_node = next((node for node in self.nodes if node[0] == Util.name_get(self.config['overlay']['this-node'])), None)

        # The name of the overlay. Also the name of the network namespace.
        self.name = Util.name_get(self.config['overlay']['name'])
        self.netns_name = self.name

        # Used to configure the overlay's BGP routing system AS number. 
        self.asn = int(self.config['overlay']['asn'])

        # Used for determining the available /31 subnets for the mesh tunnels.
        self.linknet_pool = Util.ip_network_get(self.config['overlay']['linknet-pool'])

        # Get the (absolute or relative) path to the fwbuilder script to
        # configure the firewall in this overlay.
        self.fwbuilder_script = self.config['overlay']['fwbuilder-script'] if 'fwbuilder-script' in self.config['overlay'] else None

        # Used to generate the configuration for the BIRD routing daemon.
        self.bird_config = {}
        self.bird6_config = {}
        self.bird_config_template = daemon.bird_config_template

        # Used by Overlay.interface_name().
        self.interface_names = daemon.interface_names

        # Used by Overlay.gre_key().
        self.mesh_tunnels = daemon.mesh_tunnels

        # self.static_vlans = defined in start_vlans()
        # self.static_tunnels = defined in start_tunnels()
        # self.static_veths = defined in start_veths()

        # Network namespace root directory. Used for saving network namespace
        # specific configuration files.
        self.netns_root = os.path.join(self.lib_dir, "netns", self.netns_name)

        # Sanity checks.
        if self.this_node is None:
            raise Exception("'%s' is missing from node list" % self.config['overlay']['this-node'])

        if len(self.nodes) != len(set(self.nodes)):
            raise Exception("node list contains a duplicate")

        # Initial operating state of the overlay.
        self.stopped = False

        # Start the overlay.
        self.start()


    def links(self):
        """
        Bi-directionally enumerate all of the links in a mesh, with each link's reverse immediately following it.
        """

        # The added nodes list stores the list of nodes with their links
        # already made in the list. Iterations of the list of nodes will 
        # make links to every node on on this added nodes list before
        # adding themselves to it for the next iteration.
        #
        # Creating links this way allows new nodes to be added without
        # affecting what the links() method previously generated. In other
        # words, when new hosts get added, their links get *appended* to the
        # end of the links list.

        links = []
        added_nodes = []

        for peer_node in self.nodes:
            peer_node_name = peer_node[0]
            peer_node_address = peer_node[1]

            for node_name, node_address in added_nodes:
                link = (node_name, peer_node_name)
                if node_name is not peer_node_name and link not in links and link[::-1] not in links:
                    links.append(link)
                    links.append(link[::-1])

            added_nodes.append(peer_node)

        return links


    def interface_name(self, name, suffix=None, limit=15):
        """
        Creates a valid, unique (in this overlay daemon) interface name based
        on the given base name string, and returns it.
        """

        if_name_num = 0

        while True:
            digits = len(str(if_name_num))

            if suffix is not None:
                if_name_base = re.sub('[^A-Za-z0-9]', '', name)[:limit - len(suffix) - digits]
                if_name = "%s%s%i" % (if_name_base, suffix, if_name_num)
            else:
                if_name_base = re.sub('[^A-Za-z0-9]', '', name)[:limit - digits]
                if_name = "%s%i" % (if_name_base, if_name_num)

            if if_name not in self.interface_names:
                break

            if_name_num += 1

        self.interface_names.append(if_name)
        return if_name


    def interface_get(self, name, ipdb):
        """
        Tries to find an interface with the given name in the chosen IPDB
        and returns it. Throws an exception if it can't find it.
        """

        if name in ipdb.by_name.keys():
            return ipdb.interfaces[name]
        else:
            raise Exception("unable to find interface %s in IPDB" % name)


    def interface_add_ip(self, interface, address, netmask, ipdb):
        """
        Add the given IP address (either a string, IPv4Address or IPv6Address)
        with its netmask to the interface in the chosen IPDB.
        """

        ip_tuple = (str(address), netmask)
        ip_string = "%s/%i" % ip_tuple

        if ip_tuple in interface.ipaddr:
            logging.debug("no need to add address %s to interface %s" % (ip_string, interface.ifname))
            return

        logging.debug("adding address %s to interface %s" % (ip_string, interface.ifname))

        interface.add_ip(ip_string)
        ipdb.commit()


    def interface_remove(self, interface=None, name=None, expr=None, ipdb=None, delay=0.1):
        """
        Remove an interface, or any interface matching a given regular
        expression.

        The required arguments are one of an interface object, an interface
        name, or a matching regular expression. In addition to this, an IPDB
        object is required for an interface name or a regular expression, to
        allow for the method to search for interface objects to remove.
        """

        if interface is not None:
            logging.debug("removing interface %s" % interface.ifname)

            interface.down()
            interface.remove().commit()
        elif name is not None and ipdb is not None:
            if name in ipdb.by_name.keys():
                logging.debug("removing interface %s" % name)
                interface = ipdb.interfaces[name]

                interface.down()
                interface.remove()

                ipdb.commit()
        elif expr is not None and ipdb is not None:
            for name in ipdb.by_name.keys():
                if re.match(expr, name):
                    logging.debug("removing interface %s" % name)

                    interface = ipdb.interfaces[name]

                    interface.down()
                    interface.remove()

                    ipdb.commit()
        else:
            raise Exception("invalid arguments for interface_remove: interface=%s, name=%s, expr=%s, ipdb=" % (interface.ifname if interface is not None else "None", str(name), str(expr), str(ipdb)))

        # pyroute2 seems to take a little while to actually execute
        # an interface removal. Put in an artificial delay in an attempt to
        # avoid race conditions with removing interfaces and then reusing them.
        #
        # TODO: Figure out why pyroute2 does this, and fix it upstream. Remove
        # this workaround once it is fixed.
        time.sleep(delay)


    def interface_up(self, interface):
        """
        Bring up the given interface.
        """

        logging.debug("bringing up interface %s" % interface.ifname)
        interface.up().commit()


    def bridge_create(self, name, ipdb):
        """
        Create a bridge interface with the given name in a chosen IPDB.
        Returns the interface entry from the IPDB.
        """

        if name not in ipdb.by_name.keys():
            logging.debug("creating bridge interface %s" % name)

            interface = ipdb.create(
                ifname=name,
                kind='bridge',
            )

            ipdb.commit()
        else:
            logging.debug("no need to create bridge interface %s" % name)
            interface = ipdb.interfaces[name]

        return interface


    def bridge_add_port(self, bridge, interface, ipdb):
        """
        Add the given interface to the list of ports for a given bridge.
        """

        if interface.index not in bridge.ports:
            logging.debug("adding interface %s to bridge %s" % (interface.ifname, bridge.ifname))

            bridge.add_port(interface)

            ipdb.commit()
        else:
            logging.debug("no need to add interface %s to bridge %s" % (interface.ifname, bridge.ifname))


    def gre_key(self, local, remote):
        """
        Generate a unique key value for the given (local, remote) address pair.
        """

        key = 0
        link = (local, remote)

        for l in self.mesh_tunnels:
            if l == link:
                key += 1

        return key


    def gre_create(self, name, local, remote, ipdb, kind='gre', ttl=16, key=None, ikey=None, okey=None, iflags=32, oflags=32):
        """
        Create a gre/gretap interface with the given name in a chosen ipdb.
        Returns the interface entry from the ipdb.
        """

        if key is not None:
            ikey = key
            okey = key

        if name in ipdb.by_name.keys():
            interface = ipdb.interfaces[name]

            if (interface.kind != kind or
                    # Cast for compatibility with IPv4Address/IPv6Address.
                    interface.gre_local != str(local) or
                    interface.gre_remote != str(remote) or
                    interface.gre_ttl != ttl or
                    interface.gre_ikey != ikey or
                    interface.gre_okey != okey or
                    interface.gre_iflags != iflags or
                    interface.gre_oflags != oflags):
                logging.debug("removing existing interface %s" % name)
                self.interface_remove(interface=interface)
            else:
                logging.debug("no need to create %s tunnel %s" % (kind, name))
                return interface

        logging.debug("creating %s tunnel %s" % (kind, name))

        interface = ipdb.create(
            ifname=name,
            kind=kind,
            # Cast for compatibility with IPv4Address/IPv6Address.
            gre_local=str(local),
            gre_remote=str(remote),
            gre_ttl=ttl,
            gre_ikey=ikey,
            gre_okey=okey,
            gre_iflags=iflags,
            gre_oflags=oflags,
        )

        ipdb.commit()
        return interface


    def veth_create(self, name, peer, ipdb):
        """
        Create a veth pair with the given names in the chosen IPDB, and
        returns the root interface. The peer must be retrieved separately.
        """

        if name in ipdb.by_name.keys():
            interface = ipdb.interfaces[name]

            if interface.kind != 'veth':
                logging.debug("removing existing interface %s" % name)
                self.interface_remove(interface=interface)
            else:
                logging.debug("no need to create veth pair %s and %s" % (name, peer))
                return interface

        logging.debug("creating veth pair %s and %s" % (name, peer))

        interface = ipdb.create(
            ifname=name,
            kind='veth',
            peer=peer,
        )

        ipdb.commit()
        return interface


    def vlan_create(self, name, link, id, ipdb):
        """
        Create a IEEE 802.1Q VLAN interface with the given name, physical link
        and ID in the chosen IPDB, and return the interface.
        """

        if name in ipdb.by_name.keys():
            interface = ipdb.interfaces[name]

            if (interface.kind != 'vlan' or
                    ipdb.by_index[interface.link] != link or
                    interface.vlan_id != id):
                logging.debug("removing existing interface %s" % name)
                self.interface_remove(interface=interface)
            else:
                logging.debug("no need to create vlan interface %s" % name)
                return interface
        else:
            logging.debug("creating VLAN interface %s" % name)

        interface = ipdb.create(
            ifname=name,
            kind='vlan',
            link=link,
            vlan_id=id,
        )

        ipdb.commit()
        return interface


    def netns_set(self, name, netns_name, netns_ipdb, ipdb):
        """
        Moves an interface into a chosen network namespace. Returns the
        interface object from the network namespace.
        """

        if name not in netns_ipdb.by_name.keys():
            logging.debug("moving interface %s to network namespace %s" % (name, netns_name))

            ipdb.interfaces[name].net_ns_fd = netns_name
            ipdb.commit()
        else:
            logging.debug("no need to move interface %s to network namespace %s" % (name, netns_name))

        return netns_ipdb.interfaces[name]


    def bird_config_add(self, key, value):
        """
        Add a variable to render to the BIRD configuration template.
        """

        logging.debug("adding variable %s to BIRD configuration" % key)
        self.bird_config[key] = value


    def bird6_config_add(self, key, value):
        """
        Add a variable to render to the BIRD6 configuration template.
        """

        logging.debug("adding variable %s to BIRD6 configuration" % key)
        self.bird6_config[key] = value


    def start(self):
        """
        Start the overlay.
        """

        if self.enabled == False:
            return

        if self.stopped == True:
            raise Exception("cannot restart an Overlay after it has been stopped, recreate the Overlay object instead")

        self.start_namespace()
        self.start_mesh_tunnels()
        self.start_static_vlans()
        self.start_static_tunnels()
        self.start_static_veths()
        self.start_static_bgps()
        self.start_bird()
        self.start_firewall()


    def start_namespace(self):
        """
        Create the network namespace.
        """

        try:
            netns.create(self.netns_name)
        except FileExistsError:
            logging.debug("no need to create namespace %s" % self.netns_name)
        except:
            raise Exception("could not create namespace %s" % self.netns_name)
        else:
            logging.debug("creating namespace %s" % self.netns_name)

        self.netns = NetNS(self.netns_name)
        self.ipdb = IPDB(nl=self.netns)

        # Create the network namespace root directory.
        Util.directory_create(self.netns_root)


    def start_mesh_tunnels(self):
        """
        Create the mesh tunnels which connect the network namespaces on the
        nodes.
        """

        # The netns veth interfaces address one each of a mesh tunnel.
        # Each mesh tunnel is assigned a /31 subnet to address each end of the
        # tunnel.
        #
        # The range of addresses these /31 subnets are assigned from is defined
        # by the linknet_pool overlay configuration variable.
        linknet_pool_address_base = self.linknet_pool.network_address
        linknet_pool_address_end = self.linknet_pool.broadcast_address

        # The list of mesh tunnels to add to the BIRD configuration, with their
        # IPsec encapsulations.
        gretaps = []
        ipsecs = []

        for index, link in enumerate(self.links()):
            # Check if this link requires a tunnel on this host. If not,
            # continue.
            if link[0] != self.this_node[0]:
                continue

            # Set some required data so the tunnel knows which direction it
            # needs to configure itself in.

            # Pair number. Increases for a change in nodes which are being
            # linked, rather than direction.
            pair_num = math.floor(index / 2)

            # Interface names.
            gretap_name = "m%il%i" % (self.asn, pair_num)
            ipsec_name = "%sip" % gretap_name
            bridge_name = "%sbr" % gretap_name
            root_veth_name = "%sv0" % gretap_name
            netns_veth_name = "%sv1" % gretap_name

            # IP addresses used for transit of the mesh tunnels.
            physical_local = None
            physical_remote = None

            for node, address in self.nodes:
                if node == link[0]:
                    physical_local = Util.ip_address_get(address)
                elif node == link[1]:
                    physical_remote = Util.ip_address_get(address)

                if physical_local is not None and physical_remote is not None:
                    break

            # Interface addresses for the mesh tunnel.
            netns_veth_address_local = linknet_pool_address_base + index
            netns_veth_address_remote = Util.ip_address_remote(netns_veth_address_local)
            netns_veth_address_netmask = 127 if Util.ip_network_is_v6(self.linknet_pool) else 31

            # Make sure the number of assigned subnets does not overflow
            # the linknet pool.
            if netns_veth_address_local > linknet_pool_address_end or netns_veth_address_remote > linknet_pool_address_end:
                raise Exception("overflowed linknet pool %s with link %s" % (str(self.linknet_pool), str(link)))

            logging.debug("creating mesh tunnel %s" % gretap_name)

            # Create the mesh tunnel interface.
            gretap_if = self.gre_create(
                name=gretap_name,
                kind='gretap',
                local=physical_local,
                remote=physical_remote,
                key=self.gre_key(physical_local, physical_remote),
                ipdb=self.root_ipdb,
            )

            # Create the tunnel's veth pair in the root namespace.
            root_veth_if = self.veth_create(
                name=root_veth_name,
                peer=netns_veth_name,
                ipdb=self.root_ipdb,
            )

            # Create a bridge interface.
            bridge_if = self.bridge_create(
                name=bridge_name,
                ipdb=self.root_ipdb,
            )

            # Add the root namespace veth interface and the mesh tunnel
            # interface to the bridge, linking them.
            self.bridge_add_port(
                bridge=bridge_if,
                interface=gretap_if,
                ipdb=self.root_ipdb,
            )

            self.bridge_add_port(
                bridge=bridge_if,
                interface=root_veth_if,
                ipdb=self.root_ipdb,
            )

            # Move one of the veth interfaces into the network namespace.
            netns_veth_if = self.netns_set(
                name=netns_veth_name,
                netns_name=self.netns_name,
                netns_ipdb=self.ipdb,
                ipdb=self.root_ipdb,
            )

            # Add an address to the network namespace veth interface, so it can
            # be addressed from either side of the mesh tunnel.
            self.interface_add_ip(
                interface=netns_veth_if,
                address=netns_veth_address_local,
                netmask=netns_veth_address_netmask,
                ipdb=self.ipdb,
            )

            # Bring up all interfaces.
            self.interface_up(gretap_if)
            self.interface_up(root_veth_if)
            self.interface_up(bridge_if)
            self.interface_up(netns_veth_if)

            # Add the mesh tunnel to the list of routed interfaces.
            logging.debug("adding BGP route for mesh tunnel %s" % gretap_name)

            gretaps.append({
                'interface': gretap_name,

                'local': {
                    'name': link[0],
                    'address': netns_veth_address_local,
                },

                'remote': {
                    'name': link[1],
                    'address': netns_veth_address_remote,
                },
            })

            # Add the local-remote link to the list of mesh tunnel links made.
            self.mesh_tunnels.append((physical_local, physical_remote))

            logging.debug("finished creating mesh tunnel %s" % gretap_name)

        if Util.ip_network_is_v6(self.linknet_pool):
            self.bird6_config_add(key='gretaps', value=gretaps)
        else:
            self.bird_config_add(key='gretaps', value=gretaps)


    def start_static_vlans(self):
        """
        Create a static VLAN between a physical interface on the node and the
        network namespace.
        """

        # The list of static VLANs configured.
        self.static_vlans = []

        static_vlans_bgp = []
        static_vlans_bgp6 = []

        for section in self.config.sections():
            if section.startswith('static-vlan'):
                name = Util.name_get(section.lstrip('static-vlan:'))
                id = int(self.config[section]['id'])
                physical_interface = Util.name_get(self.config[section]['physical-interface'])
                address = Util.ip_address_get(self.config[section]['address'])
                netmask = Util.netmask_get(self.config[section]['netmask'], Util.ip_address_is_v6(address))

                vlan_name = self.interface_name(name=name, suffix='vl', limit=13)
                root_veth_name = "%sv0" % vlan_name
                netns_veth_name = "%sv1" % vlan_name
                bridge_name = "%sbr" % vlan_name

                logging.debug("creating static VLAN %s" % name)

                # Find the physical interface in the IPDB.
                physical_if = self.interface_get(
                    physical_interface,
                    ipdb=self.root_ipdb,
                )

                # Create the VLAN interface.
                vlan_if = self.vlan_create(
                    name=vlan_name,
                    link=self.root_ipdb.interfaces[physical_interface],
                    id=id,
                    ipdb=self.root_ipdb,
                )

                # Create the veth pair.
                root_veth_if = self.veth_create(
                    name=root_veth_name,
                    peer=netns_veth_name,
                    ipdb=self.root_ipdb,
                )

                # Move the netns veth interface to the network namespace.
                netns_veth_if = self.netns_set(
                    name=netns_veth_name,
                    netns_name=self.netns_name,
                    netns_ipdb=self.ipdb,
                    ipdb=self.root_ipdb,
                )

                # Add the assigned address for the VLAN to the netns veth
                # interface.
                self.interface_add_ip(
                    interface=netns_veth_if,
                    address=address,
                    netmask=netmask,
                    ipdb=self.ipdb,
                )

                # Create a bridge for the physical interface to connect to the
                # network namespace via the veth pair.
                bridge_if = self.bridge_create(
                    name=bridge_name,
                    ipdb=self.root_ipdb,
                )

                # Add the physical interface and the root veth interface to the
                # bridge.
                self.bridge_add_port(
                    bridge=bridge_if,
                    interface=vlan_if,
                    ipdb=self.root_ipdb,
                )

                self.bridge_add_port(
                    bridge=bridge_if,
                    interface=root_veth_if,
                    ipdb=self.root_ipdb,
                )

                # Finally, we're done! Bring up the interfaces!
                self.interface_up(physical_if)
                self.interface_up(vlan_if)
                self.interface_up(root_veth_if)
                self.interface_up(netns_veth_if)
                self.interface_up(bridge_if)

                # Add the veth interface connected to the VLAN to the list of 
                # routed interfaces.
                static_vlan = {
                    'name': name,
                    'interface': netns_veth_name,
                    'vlan_interface': vlan_name,
                    'root_interface': root_veth_name,
                    'bridge_interface': bridge_name,
                }

                logging.debug("adding %s to list of static VLANs" % name)
                self.static_vlans.append(static_vlan)

                logging.debug("adding BGP route for static VLAN %s" % name)
                if Util.ip_address_is_v6(address):
                    static_vlans_bgp6.append(static_vlan)
                else:
                    static_vlans_bgp.append(static_vlan)

                logging.debug("finished creating static VLAN %s" % name)

        if static_vlans_bgp:
            self.bird_config_add(key='vlans', value=static_vlans_bgp)

        if static_vlans_bgp6:
            self.bird6_config_add(key='vlans', value=static_vlans_bgp6)


    def start_static_tunnels(self):
        """
        Create a static GRE or gretap tunnel in the network namespace.
        """

        # The list of static tunnels configured.
        self.static_tunnels = []

        static_tunnels_bgp = []
        static_tunnels_bgp6 = []

        for section in self.config.sections():
            if section.startswith('static-tunnel'):
                name = Util.name_get(section.lstrip('static-tunnel:'))
                mode = Util.enum_get(self.config[section]['mode'], ['gre', 'gretap'])
                local = Util.ip_address_get(self.config[section]['local'])
                remote = Util.ip_address_get(self.config[section]['remote'])
                address = Util.ip_address_get(self.config[section]['address'])
                netmask = Util.netmask_get(self.config[section]['netmask'], Util.ip_address_is_v6(address))

                tunnel_name = self.interface_name(name)

                logging.debug("creating static tunnel %s" % name)

                tunnel_if = self.gre_create(
                    name=tunnel_name,
                    kind=mode,
                    local=local,
                    remote=remote,
                    key=self.gre_key(local, remote),
                    ipdb=self.ipdb,
                )

                self.interface_add_ip(
                    interface=tunnel_if,
                    address=address,
                    netmask=netmask,
                    ipdb=self.ipdb,
                )

                self.interface_up(tunnel_if)

                # Add the tunnel to the list of routed interfaces.
                static_tunnel = {
                    'name': name,
                    'interface': tunnel_name,
                }

                logging.debug("adding %s to list of static tunnels" % name)
                self.static_tunnels.append(static_tunnel)

                logging.debug("adding BGP route for static tunnel %s" % name)
                if Util.ip_address_is_v6(address):
                    static_tunnels_bgp6.append(static_tunnel)
                else:
                    static_tunnels_bgp.append(static_tunnel)

                logging.debug("creating of static tunnel %s" % name)

        if static_tunnels_bgp:
            self.bird_config_add(key='tunnels', value=static_tunnels_bgp)

        if static_tunnels_bgp6:
            self.bird6_config_add(key='tunnels', value=static_tunnels_bgp6)


    def start_static_veths(self):
        """
        Create a static veth pair between the network namespace and the root
        namespace.
        """

        # The list of static veths configured.
        self.static_veths = []

        static_veths_bgp = []
        static_veths_bgp6 = []

        for section in self.config.sections():
            if section.startswith('static-veth'):
                name = Util.name_get(section.lstrip('static-veth:'))
                inner_address = Util.ip_address_get(self.config[section]['inner-address'])
                outer_address = Util.ip_address_get(self.config[section]['outer-address'])
                netmask = Util.netmask_get(self.config[section]['netmask'], Util.ip_address_is_v6(inner_address))

                outer_name = self.interface_name(name + 'v')
                inner_name = self.interface_name(name + 'v')

                logging.debug("creating static veth %s" % name)

                if type(inner_address) != type(outer_address):
                    raise ValueError("inner address %s is not the same type of IP address as outer address %s" % (inner_address, outer_address))

                outer_if = self.veth_create(
                    name=outer_name,
                    peer=inner_name,
                    ipdb=self.root_ipdb,
                )

                # Move the inner interface into the network namespace. The idea
                # of a static veth is that it creates a static path between the
                # root and network namespaces.
                inner_if = self.netns_set(
                    name=inner_name,
                    netns_name=self.netns_name,
                    netns_ipdb=self.ipdb,
                    ipdb=self.root_ipdb,
                )

                self.interface_add_ip(
                    interface=outer_if,
                    address=outer_address,
                    netmask=netmask,
                    ipdb=self.root_ipdb,
                )

                self.interface_add_ip(
                    interface=inner_if,
                    address=inner_address,
                    netmask=netmask,
                    ipdb=self.ipdb,
                )

                self.interface_up(outer_if)
                self.interface_up(inner_if)

                # Add the inner interface to the list of routed interfaces.
                static_veth = {
                    'name': name,
                    'interface': inner_name,
                    'outer_interface': outer_name,
                }

                logging.debug("adding %s to list of static veths" % name)
                self.static_veths.append(static_veth)

                logging.debug("adding BGP route for static veth %s" % name)
                if Util.ip_address_is_v6(inner_address):
                    static_veths_bgp6.append(static_veth)
                else:
                    static_veths_bgp.append(static_veth)

                logging.debug("finished creating static veth %s" % name)

        if static_veths_bgp:
            self.bird_config_add(key='veths', value=static_veths_bgp)

        if static_veths_bgp6:
            self.bird6_config_add(key='veths', value=static_veths_bgp6)


    def start_static_bgps(self):
        """
        Create a static BGP protocol in the network namespace.
        """

        # The list of static BGP protocols to add to the BIRD configuration.
        bgps = []
        bgps6 = []

        for section in self.config.sections():
            if section.startswith('static-bgp'):
                bgp = {}

                name = Util.name_get(section.lstrip('static-bgp:'))
                neighbor = Util.ip_address_get(self.config[section]['neighbor'])
                local = Util.ip_address_get(self.config[section]['local']) if 'local' in self.config[section] else None

                local_asn = int(self.config[section]['local-asn']) if 'local-asn' in self.config[section] else self.asn
                neighbor_asn = int(self.config[section]['neighbor-asn']) if 'neighbor-asn' in self.config[section] else self.asn

                description = self.config[section]['description'] if 'description' in self.config[section] else None

                bgp['name'] = name
                bgp['neighbor'] = str(neighbor)
                if local is not None:
                    bgp['local'] = str(local)

                bgp['local_asn'] = local_asn
                bgp['neighbor_asn'] = neighbor_asn

                if description is not None:
                    bgp['description'] = description

                # The import prefixes is a list of IP address subnets to filter
                # the BGP protocol's import function against.
                import_prefixes = []
                for key in self.config[section].keys():
                    if key.startswith('import-prefix'):
                        import_prefixes.append(self.config[section][key])

                if len(import_prefixes) > 0:
                    bgp['import_prefixes'] = [Util.bird_prefix_get(prefix) for prefix in import_prefixes]

                # Add the static BGP to either the BIRD or BIRD6 configuration,
                # depending on whether IPv6 is used at all or not.
                logging.debug("adding static BGP %s to BIRD configuration" % name)

                if Util.ip_address_is_v6(neighbor) or (local is not None and Util.ip_address_is_v6(local)):
                    bgps6.append(bgp)
                else:
                    bgps.append(bgp)

                logging.debug("finished adding static BGP %s to BIRD configuration" % name)

        if bgps:
            self.bird_config_add(key='bgps', value=bgps)

        if bgps6:
            self.bird_config_add(key='bgps', value=bgps6)


    def start_bird_daemon(self, bird, bird_config_file, bird_socket_file, bird_pid_file):
        # If there is a BIRD daemon already running, connect to its socket and
        # tell it to reload its configuration.
        if Util.pid_exists(pid_file=bird_pid_file):
            try:
                logging.debug("reloading BIRD")

                logging.debug("connecting to the BIRD control socket")

                sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                sock.connect(bird_socket_file)

                datagram = sock.recv(1024)
                response = datagram.decode('UTF-8')

                if not re.match("0001 BIRD [0-9.]* ready.\n", response):
                    raise Exception("unable to connect to BIRD. output:\n%s" % response)

                logging.debug("reloading BIRD configuration")

                sock.send(bytes("configure \"%s\"\n" % bird_config_file, 'UTF-8'))

                datagram = sock.recv(1024)
                response = datagram.decode('UTF-8')

                if "0002-Reading configuration from %s" % bird_config_file not in response or ("0003 Reconfigured" not in response and "0004 Reconfiguration in progress" not in response):
                    raise Exception("unable to reload BIRD configuration. output:\n%s" % response)

                sock.close()
                logging.debug("finished reloading BIRD")
                return
            except socket.error as e:
                if e.errno != errno.ECONNREFUSED:
                    raise

        # If not, then start a new BIRD daemon. 
        try:
            ip = find_executable("ip")

            if ip is None:
                raise Exception("cannot find ip (iproute2) executable path")

            logging.debug("starting BIRD")

            subprocess.check_output([
                ip, "netns", "exec", self.netns_name,
                bird,
                    "-c", bird_config_file,
                    "-s", bird_socket_file,
                    "-P", bird_pid_file,
            ], stderr=subprocess.STDOUT)

            logging.debug("finished starting BIRD")
        except subprocess.CalledProcessError as e:
            logging.error("error detected in process call:\n%s" % e.output.decode('UTF-8'))
            raise


    def start_bird(self):
        """
        Configure and start the BIRD routing daemon.
        """

        logging.debug("starting the BIRD routing daemon")

        # BIRD file paths.
        bird_config_dir = os.path.join(self.netns_root, "etc", "bird")
        bird_config_file = os.path.join(bird_config_dir, "bird.conf")

        bird_socket_dir = os.path.join(self.netns_root, "run", "bird")
        bird_socket_file = os.path.join(bird_socket_dir, "bird.ctl")
        bird_pid_file = os.path.join(bird_socket_dir, "bird.pid")

        bird6_config_dir = os.path.join(self.netns_root, "etc", "bird")
        bird6_config_file = os.path.join(bird_config_dir, "bird6.conf")

        bird6_socket_dir = os.path.join(self.netns_root, "run", "bird")
        bird6_socket_file = os.path.join(bird_socket_dir, "bird6.ctl")
        bird6_pid_file = os.path.join(bird_socket_dir, "bird6.pid")

        # Create the required BIRD directories.
        logging.debug("creating BIRD configuration directory")
        Util.directory_create(bird_config_dir)

        logging.debug("creating BIRD socket directory")
        Util.directory_create(bird_socket_dir)

        # Actual configuration time.
        logging.debug("configuring BIRD")

        # Add required parameters to the BIRD configuration.
        if self.bird_config:
            self.bird_config_add(key='file', value=bird_config_file)
            self.bird_config_add(key='netns', value=self.netns_name)
            self.bird_config_add(key='asn', value=self.asn)

        if self.bird6_config:
            self.bird6_config_add(key='file', value=bird6_config_file)
            self.bird6_config_add(key='netns', value=self.netns_name)
            self.bird6_config_add(key='asn', value=self.asn)

        # Save the BIRD configuration.
        if self.bird_config:
            logging.debug("saving bird configuration to disk")
            f = open(bird_config_file, 'w')
            f.write(self.bird_config_template.render(self.bird_config))
            f.close()

        if self.bird6_config:
            logging.debug("saving bird6 configuration to disk")
            f = open(bird6_config_file, 'w')
            f.write(self.bird_config_template.render(self.bird6_config))
            f.close()

        logging.debug("finished configuring BIRD")

        # Start the BIRD routing daemon for both IPv4 and IPv6.
        if self.bird_config:
            bird = find_executable("bird")

            if bird is None:
                raise Exception("cannot find bird executable path")

            self.start_bird_daemon(
                bird,
                bird_config_file,
                bird_socket_file,
                bird_pid_file,
            )

        if self.bird6_config:
            bird6 = find_executable("bird6")

            if bird6 is None:
                raise Exception("cannot find bird6 executable path")

            self.start_bird_daemon(
                bird6,
                bird6_config_file,
                bird6_socket_file,
                bird6_pid_file,
            )

        logging.debug("finished starting the BIRD routing daemon")


    def start_firewall(self):
        """
        Run the fwbuilder script in the network namespace.
        """

        if self.fwbuilder_script is not None:
            try:
                ip = find_executable("ip")

                if ip is None:
                    raise Exception("cannot find ip (iproute2) executable path")

                if os.path.isabs(self.fwbuilder_script):
                    command = self.fwbuilder_script
                else:
                    command = os.path.join(self.fwbuilder_script_dir, self.fwbuilder_script)

                logging.debug("building firewall for namespace %s" % self.netns_name)

                subprocess.check_output([
                    ip, "netns", "exec", self.netns_name,
                    command,
                ], stderr=subprocess.STDOUT)

                logging.debug("finished building firewall for namespace %s" % self.netns_name)

            except subprocess.CalledProcessError as e:
                logging.error("error detected in process call:\n%s" % e.output.decode('UTF-8'))
                raise


    def stop(self):
        """
        Stop the overlay.
        """

        if self.enabled == False:
            return

        # Ensure this Overlay object cannot be restarted.
        self.stopped = True

        # Already removed because it is entirely contained in the network namespace.
        # self.stop_firewall()
        self.stop_bird()
        # Already removed because it is entirely contained in BIRD.
        # self.stop_static_bgps()
        self.stop_static_veths()
        self.stop_static_tunnels()
        self.stop_static_vlans()
        self.stop_mesh_tunnels()
        self.stop_namespace()


    def stop_namespace(self):
        """
        Delete the network namespace.
        """

        logging.debug("removing namespace %s" % self.netns_name)

        logging.debug("releasing the IPDB for namespace %s" % self.netns_name)
        self.ipdb.release()

        logging.debug("closing the netns for namespace %s" % self.netns_name)
        self.netns.close()

        logging.debug("removing the netns for namespace %s" % self.netns_name)
        netns.remove(self.netns_name)

        logging.debug("removing the netns root tree for namespace %s" % self.netns_name)
        shutil.rmtree(self.netns_root)

        logging.debug("removed namespace %s" % self.netns_name)


    def stop_mesh_tunnels(self):
        """
        Destroy the root namespace components of the mesh tunnels.
        """

        logging.debug("removing mesh tunnels")

        self.interface_remove(
            expr="^m%il[0-9][0-9]*br$" % self.asn,
            ipdb=self.root_ipdb,
        )

        self.interface_remove(
            expr="^m%il[0-9][0-9]*v0$" % self.asn,
            ipdb=self.root_ipdb,
        )

        self.interface_remove(
            expr="^m%il[0-9][0-9]*$" % self.asn,
            ipdb=self.root_ipdb,
        )

        logging.debug("finished removing mesh tunnels")


    def stop_static_tunnels(self):
        """
        Destroy the static tunnels.
        """

        for tunnel in self.static_tunnels:
            name = tunnel['name']
            tunnel_name = tunnel['interface']

            logging.debug("removing static tunnel %s" % name)

            self.interface_remove(
                name=tunnel_name,
                ipdb=self.ipdb,
            )

            logging.debug("finished removing static tunnel %s" % name)


    def stop_static_vlans(self):
        """
        Destroy the root namespace components of the static VLANs.
        """

        for vlan in self.static_vlans:
            name = vlan['name']

            logging.debug("removing static VLAN %s" % name)

            self.interface_remove(
                name=vlan['bridge_interface'],
                ipdb=self.root_ipdb,
            )

            self.interface_remove(
                name=vlan['root_interface'],
                ipdb=self.root_ipdb,
            )

            self.interface_remove(
                name=vlan['vlan_interface'],
                ipdb=self.root_ipdb,
            )

            logging.debug("finished removing static VLAN %s" % name)


    def stop_static_veths(self):
        """
        Destroy the root namespace components of the static veth pairs.
        """

        for veth in self.static_veths:
            name = veth['name']

            logging.debug("removing static veth %s" % name)

            self.interface_remove(
                name=veth['outer_interface'],
                ipdb=self.root_ipdb,
            )

            logging.debug("finished removing static veth %s" % name)


    def stop_bird(self):
        """
        Stop the BIRD routing daemon. The configuration gets destroyed when
        the network namespace root directory gets cleaned up.
        """

        bird_pid_file = os.path.join(self.netns_root, "run", "bird", "bird.pid")
        bird6_pid_file = os.path.join(self.netns_root, "run", "bird", "bird6.pid")

        logging.debug("stopping the BIRD routing daemon")

        pid = Util.pid_get(pid_file=bird_pid_file)
        pid6 = Util.pid_get(pid_file=bird6_pid_file)

        if pid is not None:
            os.kill(pid, signal.SIGTERM)

        if pid6 is not None:
            os.kill(pid6, signal.SIGTERM)

        logging.debug("stopped the BIRD routing daemon")


class Util(object):


    #
    ## Argument/parameter processing.
    #

    @staticmethod
    def ip_network_get(value):
        """
        Get an IP network from a string. Raises a ValueError if the string
        is not a valid IP network. Supports both IPv4 and IPv6.
        """

        return ipaddress.ip_network(value)


    @staticmethod
    def ip_network_is_v6(value):
        """
        Returns true if the given IP network is an IPv6 network.
        Supports an integer, string, IPv4Network or IPv6Network.
        Raises a ValueError if the given value is not a valid IP network.
        """

        if isinstance(value, ipaddress.IPv6Network):
            return True
        elif isinstance(value, ipaddress.IPv4Network):
            return False

        return isinstance(ipaddress.ip_network(value), ipaddress.IPv6Network)


    @staticmethod
    def ip_address_get(value):
        """
        Get an IP address from a string. Raises a ValueError if the string
        is not a valid IP address. Supports both IPv4 and IPv6.
        """

        return ipaddress.ip_address(value)


    @staticmethod
    def ip_address_remote(local):
        """
        For a given local_address (either an integer, IPv4Address or
        IPv6Address), return the other end of a two-node linknet
        (/31 for IPv4, /127 for IPv6).
        """

        return ipaddress.ip_address(int(local) ^ 1)


    @staticmethod
    def ip_address_is_v6(value):
        """
        Returns true if the given IP address is an IPv6 address.
        Supports an integer, string, IPv4Address or IPv6Address.
        Raises a ValueError if the given value is not a valid IP address.
        """

        if isinstance(value, ipaddress.IPv6Address):
            return True
        elif isinstance(value, ipaddress.IPv4Address):
            return False

        return isinstance(ipaddress.ip_address(value), ipaddress.IPv6Address)


    @staticmethod
    def netmask_get(value, use_ipv6=False):
        """
        Get a subnet mask from a string. Raises a ValueError if the string
        is not a valid subnet mask. Supports both CIDR and dotted decimal form.
        """

        maxlen = 128 if use_ipv6 else 32

        if re.match("\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}", value):
            if use_ipv6:
                raise ValueError("dotted decimal netmask invalid when use_ipv6 is true, use CIDR instead")

            return Util.netmask_dd_to_cidr(value)

        cidr = int(value)

        if cidr > maxlen or cidr < 0:
            raise ValueError("valid CIDR netmask %i, must be within range 0 < x < 128" % cidr)

        return cidr


    @staticmethod
    def netmask_dd_to_cidr(netmask):
        """
        Convert a netmask in dotted decimal form to the CIDR form.
        """

        i = 0
        integer = 0
        segments = netmask.split('.')

        for index, segment in enumerate(segments):
            seg = int(segment)

            if seg > 255 or seg < 0:
                raise ValueError("invalid dotted decimal netmask %s" % netmask)

            integer += (seg << (24 - (8 * index)))

        for b in bin(integer)[2:]:
            if b == '1':
                i += 1
            else:
                break

        return i


    @staticmethod
    def boolean_get(value):
        """
        Get a boolean value from a string. Raise a ValueError if the string
        is not a valid boolean.
        """

        lower_value = value.lower()

        if lower_value != "true" and lower_value != "false":
            raise ValueError("invalid value for boolean: %s" % lower_value)

        return True if lower_value == "true" else False


    @staticmethod
    def name_get(value):
        """
        Check that a string is a valid name, and return it. A name is a string
        that is just one word, without whitespace. Raise a ValueError if the 
        string is not a valid name.
        """

        name = value.strip()

        if len(name) == 0:
            raise ValueError("empty string not a valid name")

        if not re.fullmatch("[^\s][^\s]*", value):
            raise ValueError("given string not a valid name (contains whitespace): %s" % name)

        return name


    @staticmethod
    def hex_get_string(value, min=None, max=None):
        """
        Check that a string is a valid hexadecimal integer, optionally
        checking if it is within a minimum and maximum length. Returns the 
        string if the conditions are satisfied, raises a ValueError otherwise.
        """

        length = len(value)

        if length == 0:
            raise ValueError("empty string not a valid hexadecimal integer")

        if min is not None and length < min:
            raise ValueError("hexadecimal integer too short, minimum %i digits required: %s" % (min, value))

        if max is not None and length > max:
            raise ValueError("hexadecimal integer too long, maximum %i digits required: %s" % (max, value))

        if not re.fullmatch("[0-9A-Fa-f][0-9A-Fa-f]*", value):
            raise ValueError("given string not a valid hexadecimal integer: %s" % value)

        return value


    @staticmethod
    def enum_get(value, enum):
        """
        Check that the given value string is in the list of enumeration string
        values, and return the enumeration value the value string is
        equivalent to. Raise a ValueError if it is not in the list.
        """

        for e in enum:
            if value.lower() == e.lower():
                return e

        raise ValueError("given value %s is not a valid enum, must be one of %s" % (value, str(enum)))


    @staticmethod
    def bird_prefix_get(value):
        """
        Check that a string is a BIRD prefix, and return it. Raise a
        ValueError if the string is not a valid BIRD prefix.

        This method allows the use of prefix patterns that are allowed to be
        used in sets of prefixes in BIRD filters.

        Check the BIRD documentation here for more information on BIRD
        prefixes:

        http://bird.network.cz/?get_doc&f=bird-5.html#ss5.2
        """

        prefix = re.split("/", value)

        # Get the IP address and convert it to an IP address object using
        # Util.ip_address_get, to ensure it is a real IP address.
        try:
            address = Util.ip_address_get(prefix[0])
        except ValueError:
            raise ValueError("given value %s is not a valid BIRD prefix, invalid address segment" % value)

        # Check for a valid netmask in the netmask segment.
        try:
            netmask = Util.netmask_get(re.match("[0-9][0-9]*", prefix[1]).group(), Util.ip_address_is_v6(address))
        except ValueError:
            raise ValueError("given value %s is not a valid BIRD prefix, invalid netmask segment" % value)

        # The interesting part about BIRD prefixes, syntatically, is in the
        # netmask segment, which can not just be CIDR numbers, but can also be
        # special expressions, depending on the range of subnets required.
        #
        # This expression can take the following forms:
        # 10.192.0.0/16+ - match all subprefixes of 10.192.0.0/16
        # 10.192.0.0/16- - match all superprefixes of 10.192.0.0/16
        # 10.192.0.0/16{20,24} - match all subprefixes of 10.192.0.0/16 which
        #                        have a prefix length of between 20 to 24.
        #
        # This part checks that the syntax for those expressions is correct.
        expr = re.sub("^%i" % netmask, "", prefix[1])

        if expr:
            if not re.match("^[+-]$", expr) and re.match("^\{[0-9][0-9]*,[0-9][0-9]*\}$", expr):
                netmasks = re.findall("[0-9][0-9]*", expr)

                for n in netmask:
                    try:
                        netmask = Util.netmask_get(n, Util.ip_address_is_v6(address))
                    except ValueError:
                        raise ValueError("given value %s is not a valid BIRD prefix, invalid netmask %i in expression segment" % (value, n))
            else:
                raise ValueError("given value %s is not a valid BIRD prefix, invalid expression segment" % value)

        # All checks have passed. Return the value unmodified.
        return value


    #
    ## File system helper methods.
    #

    @staticmethod
    def path_my_dir():
        """
        Return the directory containing this script.
        """

        return os.path.dirname(os.path.realpath(sys.argv[0]))


    @staticmethod
    def path_root():
        """
        Return the operating system root directory. System independent.
        """

        return os.path.abspath(os.sep)


    @staticmethod
    def path_search(filename, paths):
        """
        Returns the first instance of a valid filepath, made from the given 
        filename joined with each element from the list of paths. If it doesn't
        find a match, returns the final filepath combination from the list.

        Works with both files and directories, but does not distinguish them.
        """

        for path in paths:
            filepath = os.path.join(path, filename)
            if (os.path.exists(filepath)):
                return filepath

        return filepath


    @staticmethod
    def directory_create(path, mode=None):
        """
        Make the directory tree defined in the given file path, including all
        intermediate directories. If the path already exists and is a 
        directory, does nothing.
        """
        if not os.path.exists(path):
            if mode is not None:
                os.makedirs(path, mode)
            else:
                os.makedirs(path)
        elif not os.path.isdir(path):
            raise Exception("file path at %s already exists, but is not a directory" % path)

    #
    ## Checking helper methods.
    #

    @staticmethod
    def pid_get(pid=None, pid_file=None):
        """
        Checks for the existence of a PID on the running system. If true,
        returns the PID number. If false, returns None.

        Can either use a PID number directly, or take in a PID file and check
        that. If the PID file is not valid or the PID contained inside does 
        not exist, this method deletes that PID file.
        """

        if pid and pid_file:
            raise ValueError("pid and pid_file are mutually exclusive arguments")

        if pid_file is not None:
            if os.path.exists(pid_file):
                f = open(pid_file, 'r')
                pid_file_data = f.read().strip()
                f.close()

                if len(pid_file_data) > 0 and re.match("[0-9][0-9]*", pid_file_data):
                    pid = int(pid_file_data)
                else:
                    # Invalid PID file. Remove it.
                    os.remove(pid_file)
                    return None
            else:
               # PID file doesn't exist.
               return None
        elif pid is None:
            raise ValueError("must specify one of pid or pid_file")

        if pid <= 0:
            if pid_file is not None:
                raise ValueError("invalid PID: %i from file: %s" % (pid, pid_file))
            else:
                raise ValueError("invalid PID: %i" % pid)

        try:
            os.kill(pid, 0)
        except OSError as e:
            # ESRCH = No such process
            if e.errno == errno.ESRCH:
                return None
            # EPERM = Permission denied
            # A process clearly exists if we don't have access to it.
            elif e.errno == errno.EPERM:
                return pid
            # EINVAL = Invalid signal
            # Something went wrong.
            else:
                raise
        # No exception - process exists
        else:
            return pid


    @staticmethod
    def pid_exists(pid=None, pid_file=None):
        """
        Checks for the existence of a PID on the running system.

        This method is a wrapper method for Util.pid_get() for it to return
        a boolean value if the returned PID number is not required. Therefore,
        it follows the same behaviour as Util.pid_get() with respect to
        raising exceptions and handling PID files.
        """

        return True if Util.pid_get(pid, pid_file) is not None else False


def close_overlays(signum, frame):
    """
    Shut down all overlays and IPsec tunnels and clean up and temporary files
    before exiting.
    """

    daemon.shutdown()
    os.remove(pid_file)

    sys.exit(0)


def reload_overlays(signum, frame):
    """
    Stop the OverlayDaemon, reload the configuration, and restart it.
    """

    logging.info("Restarting daemon...")

    daemon.stop()
    daemon.start()

    logging.info("Restarted.")


if __name__ == "__main__":
    # Define the search paths. Search for configuration files in the
    # following locations, in this order:
    # 1. (current working directory)
    # 2. (current working directory)/etc/l3overlay
    # 3. (current working directory)/../etc/l3overlay
    # 4. (executable directory)
    # 5. (executable directory)/etc/l3overlay
    # 6. (executable directory)/../etc/l3overlay
    # 7. /etc/l3overlay
    paths = [
        os.getcwd(),
        os.path.join(os.getcwd(), "etc", "l3overlay"),
        os.path.join(os.getcwd(), "..", "etc", "l3overlay"),
        Util.path_my_dir(),
        os.path.join(Util.path_my_dir(), "etc", "l3overlay"),
        os.path.join(Util.path_my_dir(), "..", "etc", "l3overlay"),
        os.path.join(Util.path_root(), "etc", "l3overlay"),
    ]

    lib_dir = os.path.join(Util.path_root(), "var", "lib", "l3overlay")
    log_dir = os.path.join(Util.path_root(), "var", "log")
    run_dir = os.path.join(Util.path_root(), "var", "run")

    # Use the path list to search for these files and directories.
    template_dir = Util.path_search("templates", paths)

    global_conf = Util.path_search("global.conf", paths)
    overlay_conf_dir = Util.path_search("overlays", paths)

    fwbuilder_script_dir = Util.path_search("fwbuilder_scripts", paths)

    log_file = os.path.join(log_dir, "l3overlay.log")
    pid_file = os.path.join(run_dir, "l3overlayd.pid")

    # Parse optional arguments, and return the final values which will be used
    # in l3overlayd configuration.
    argparser = argparse.ArgumentParser(description="Construct one or more MPLS-like VRF networks using IPsec tunnels and network namespaces.")

    argparser.add_argument(
        '--global-conf',
        metavar='FILE',
        type=str,
        default=global_conf,
        help="use FILE as the global configuration file",
    )

    argparser.add_argument(
        '--overlay-conf-dir',
        metavar='DIR',
        type=str,
        default=overlay_conf_dir,
        help="use DIR as the overlay conf search directory",
    )

    argparser.add_argument(
        '--fwbuilder-script-dir',
        metavar='DIR',
        type=str,
        default=fwbuilder_script_dir,
        help="use DIR as the fwbuilder script search directory",
    )

    argparser.add_argument(
        '--overlay-conf',
        metavar='FILE',
        type=str,
        nargs='+',
        default=None,
        help="configure the overlay defined in FILE",
    )

    args = argparser.parse_args()

    # Look for an existing l3overlayd PID file lock. If there is one and the
    # PID actually exists, shut down this instance and warn the user. If there
    # is a PID file and it doesn't contain a valid process, remove the PID lock
    # and start anyway.
    old_pid = Util.pid_get(pid_file=pid_file)

    if old_pid is not None:
        raise RuntimeError("valid PID lock file at %s, to start a new l3overlayd instance, kill the running l3overlayd instance with the PID %i" % (pid_file, old_pid))

    # Find all available overlay configuration files, and build those overlays.
    overlay_paths = []

    for overlay in os.listdir(args.overlay_conf_dir):
        overlay_path = os.path.join(args.overlay_conf_dir, overlay)
        if os.path.isfile(overlay_path):
            overlay_paths.append(overlay_path)

    if args.overlay_conf is not None:
        for overlay_path in args.overlay_conf:
            overlay_paths.append(overlay_path)

    # Launch a new OverlayDaemon, which takes in all of the configured data and
    # starts/stops the overlays.
    daemon = OverlayDaemon(
        template_dir=template_dir,
        lib_dir=lib_dir,
        log_file=log_file,
        global_conf=args.global_conf,
        fwbuilder_script_dir=args.fwbuilder_script_dir,
        overlay_paths=overlay_paths,
    )

    # Invoke the shutdown routine when receiving the SIGTERM signal.
    signal.signal(signal.SIGTERM, close_overlays)

    # Invoke the reload routine when receiving the SIGHUP signal.
    signal.signal(signal.SIGHUP, reload_overlays)

    # Save the PID of this daemon to a file. This serves as a lock for
    # l3overlayd, and allows it to be monitored by external processes.
    f = open(pid_file, 'w')
    f.write("%i\n" % os.getpid())
    f.close()

    os.chmod(pid_file, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH)

    # The daemon is now started. Wait until we receive a signal.
    signal.pause()
