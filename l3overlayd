#!/usr/bin/python3
#
# Copyright (c) 2016 Catalyst.net Ltd
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import argparse
import configparser
import errno
import hashlib
import ipaddress
import logging
import math
import os
import re
import shutil
import signal
import socket
import stat
import subprocess
import sys

from distutils.spawn import find_executable

from jinja2 import Environment
from jinja2 import FileSystemLoader

from pyroute2 import IPDB
from pyroute2 import netns
from pyroute2 import NetNS

class OverlayDaemon(object):

    def __init__(self, template_dir, lib_dir, global_conf, fwbuilder_script_dir, overlay_paths):

        # Directory which stores configuration templates.
        self.template_dir = template_dir

        # Directory for l3overlayd state information.
        self.lib_dir = lib_dir

        # Filepath for the global configuration file.
        self.global_conf = global_conf

        # Directory for fwbuilder scripts.
        self.fwbuilder_script_dir = fwbuilder_script_dir

        # Filepaths to the overlay configuration files.
        self.overlay_paths = tuple(overlay_paths)

        # Initial state for an OverlayDaemon is stopped, and NOT shut down.
        self.stopped = True
        self.shut_down = False

        # Root namespace IPDB. Ideally, this would be loaded in config_load(),
        # but IPDB's weren't designed to be started and stopped more than once
        # in an instance.
        self.ipdb = IPDB()

        # OverlayDaemon starting routine.
        self.start()


    def config_load(self):
        """
        Load the runtime configuration for this OverlayDaemon.
        """

        # Load the global configuration file.
        if os.path.exists(self.global_conf):
            config = configparser.ConfigParser()
            config.read(self.global_conf)

            self.config_env = Environment(
                trim_blocks=True,
                loader=FileSystemLoader(template_dir),
            )
        else:
            config = {'global': {}}

        # Logging level.
        self.logging_level = config['global']['logging-level'] if 'logging-level' in config['global'] else logging.INFO

        # Check whether or not to use IPsec.
        if 'use-ipsec' in config['global']:
            self.use_ipsec = get_boolean(config['global']['use-ipsec'])
        else:
            self.use_ipsec = False

        # Determine whether or not to save ipsec.conf as the global IPsec
        # configuration or as an additional configuration file.s
        if 'use-ipsec' in config['global']:
            self.ipsec_d = get_boolean(config['global']['ipsec-d']) if 'ipsec-d' in config['global'] else False
        else:
            self.ipsec_d = False

        # IPsec PSK, to be configured onto all tunnels.
        self.ipsec_psk = get_hex_string(config['global']['ipsec-psk'], min=6, max=64) if self.use_ipsec == True else None

        #
        # Find external files needed in overlay configuration.
        #

        # Used to generate the BIRD routing daemon configurations.
        self.bird_config_template = self.config_env.get_template('bird.conf')

        # Used to generate the IPsec tunnel configuration.
        self.ipsec_config_template = self.config_env.get_template('ipsec.conf')
        self.ipsec_secrets_template = self.config_env.get_template('ipsec.secrets')

        #
        # Runtime data structures and objects.
        #

        # Used by Overlay.interface_name() to store the interface names already
        # generated by itself, so it can generate a unique one in the next run.
        self.interface_names = []

        # List of mesh tunnel links that have been made, and how many times
        # they have been made (by allowing duplicates in the list).
        #
        # Used by Overlay.gre_key() to store the amount of times a specific
        # link has been used to create a GRE tunnel, so it can return a unique
        # key for the next one.
        #
        # Also used by start_ipsec() and stop_ipsec() to generate the IPsec
        # tunnels that are used to encapsulate the GRE tunnels.
        self.mesh_tunnels = []

        # List of overlays.
        self.overlays = []


    def ipsec_config_add(self, key, value):
        """
        Add a variable to render to the IPsec configuration template.
        """

        logging.debug("adding variable %s to ipsec configuration" % key)
        self.ipsec_config[key] = value


    def start(self):
        """
        Start this OverlayDaemon, and all of its configured overlays.
        """

        if self.shut_down == True:
            raise Exception("OverlayDaemon permanently shut down, cannot start again")

        if self.stopped == False:
            return

        self.stopped = False

        # Load the runtime configuration data.
        self.config_load()

        logging.basicConfig(level=self.logging_level)
        logging.info("Starting daemon...")

        # Create the runtime directories.
        self.start_directories()

        # Start all of the configured overlays.
        for overlay_path in overlay_paths:
            self.overlays.append(Overlay(self, overlay_path))

        # Start the IPsec tunnels for the overlays.
        self.start_ipsec()

        logging.info("Started.")


    def start_directories(self):
        """
        Create the runtime directories for this OverlayDaemon, securely, with
        the correct umask.
        """

        # Set the umask so that any files that this OverlayDaemon creates, will
        # only be readable and writable by itself.
        os.umask(stat.S_IRWXG | stat.S_IRWXO)

        # Create the libdir.
        if os.path.exists(self.lib_dir):
            shutil.rmtree(self.lib_dir)

        os.makedirs(self.lib_dir)

    def start_ipsec(self):
        """
        Configure and start the strongSwan IPsec tunnel daemon, if enabled.
        """

        if self.ipsec_d == True:
            ipsec_config_dir = os.path.join(root_path(), "etc", "ipsec.d")
            ipsec_config_file = os.path.join(ipsec_config_dir, "l3overlay.conf")
        else:
            ipsec_config_dir = os.path.join(root_path(), "etc")
            ipsec_config_file = os.path.join(ipsec_config_dir, "ipsec.conf")

        ipsec_secrets_stub_dir = os.path.join(root_path(), "etc")
        ipsec_secrets_stub_file = os.path.join(ipsec_secrets_stub_dir, "ipsec.secrets")

        ipsec_secrets_file = os.path.join(self.lib_dir, "ipsec.secrets")

        # Save the IPsec configuration.
        logging.debug("saving ipsec configuration to disk")

        f = open(ipsec_config_file, 'w')
        f.write(self.ipsec_config_template.render(
            file=ipsec_config_file,
            mesh_tunnels=self.mesh_tunnels,
        ))
        f.close()

        # Create the IPsec config directory.
        if not os.path.exists(ipsec_config_dir):
            logging.debug("creating ipsec configuration directory")
            os.makedirs(ipsec_config_dir)
        else:
            logging.debug("no need to create ipsec configuration directory")

        logging.debug("starting configuration of ipsec")

        # Save the IPsec configuration.
        logging.debug("saving ipsec configuration to disk")

        f = open(ipsec_config_file, 'w')
        f.write(self.ipsec_config_template.render(
            file=ipsec_config_file,
            mesh_tunnels=self.mesh_tunnels,
        ))
        f.close()

        # Save the stub for the ipsec.secrets file at /etc/ipsec.secrets,
        # which includes the real one.
        if not os.path.exists(ipsec_config_dir):
            logging.debug("creating ipsec secrets stub directory")
            os.makedirs(ipsec_config_dir)
        else:
            logging.debug("no need to create ipsec secrets stub directory")

        logging.debug("saving ipsec secrets stub file to disk")
        f = open(ipsec_secrets_stub_file, 'w')
        f.write("include %s\n" % ipsec_secrets_file)
        f.close()

        # Save the REAL ipsec.secrets.
        logging.debug("saving ipsec secrets file to disk")

        addresses = []

        for local, remote in self.mesh_tunnels:
            if local not in addresses:
                addresses.append(local)

            if remote not in addresses:
                addresses.append(remote)

        f = open(ipsec_secrets_file, 'w')
        f.write(self.ipsec_secrets_template.render(
            addresses=addresses,
            secret=self.ipsec_psk,
        ))
        f.close()

        logging.debug("finished configuration of ipsec")

        # Start IPsec, or, if it is already running, reload the configuration.
        try:
            ipsec = find_executable("ipsec")

            if ipsec is None:
                raise Exception("cannot find ipsec executable path")

            status = subprocess.call(
                [ipsec, "status"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )

            if status == 0:
                logging.debug("reloading ipsec")

                subprocess.check_output(
                    [ipsec, "rereadsecrets"],
                    stderr=subprocess.STDOUT,
                )

                subprocess.check_output(
                    [ipsec, "reload"],
                    stderr=subprocess.STDOUT,
                )

                logging.debug("finished reloading ipsec")
            elif status == 3:
                logging.debug("starting ipsec")

                subprocess.check_output(
                    [ipsec, "start"],
                    stderr=subprocess.STDOUT,
                )

                logging.debug("finished starting ipsec")
            else:
                raise Exception("unexpected return code for ipsec status %i" % status)

        except subprocess.CalledProcessError as e:
            logging.error("error detected in process call:\n%s" % e.output.decode('UTF-8'))
            raise


    def stop(self):
        """
        Shut down all overlays in OverlayDaemon. Once an OverlayDaemon is
        stopped, it cannot be restarted.
        """

        if self.stopped == True:
            return

        self.stopped = True

        logging.info("Stopping daemon...")

        daemon.stop_ipsec()

        for overlay in self.overlays:
            overlay.stop()

        daemon.stop_directories()
        logging.info("Stopped.")


    def stop_directories(self):
        """
        Destroy the runtime directories.
        """

        shutil.rmtree(self.lib_dir)


    def stop_ipsec(self):
        """
        Stop the strongSwan IPsec tunnel daemon, and destroy the configuration,
        if enabled.
        """

        if self.use_ipsec == False:
            return

        ipsec_config_dir = os.path.join(root_path(), "etc")

        logging.debug("stopping ipsec")

        try:
            ipsec = find_executable("ipsec")

            if ipsec is None:
                raise Exception("cannot find ipsec executable path")

            subprocess.check_output(
                [ipsec, "stop"],
                stderr=subprocess.STDOUT,
            )
        except subprocess.CalledProcessError as e:
            logging.error("error detected in process call:\n%s" % e.output.decode('UTF-8'))
            raise

        os.remove(os.path.join(ipsec_config_dir, "ipsec.conf"))
        os.remove(os.path.join(ipsec_config_dir, "ipsec.secrets"))

        logging.debug("finished stopping ipsec")


    def shutdown(self):
        """
        Permanently shut down this OverlayDaemon.
        Only use if the program is exiting.
        """

        if self.shut_down == True:
            return

        self.shut_down = True

        logging.info("Shutting down daemon...")

        self.stop()
        daemon.ipdb.release()

        logging.info("Shut down.")


class Overlay(object):


    @staticmethod
    def remote_address(local_address):
        """
        For a given local_address (either an integer or an IPv4Address), return the other end of a /31 linknet.
        """

        return ipaddress.ip_address(int(local_address) ^ 1)


    @staticmethod
    def netmask_dd_to_cidr(netmask):
        """
        Convert a netmask in dotted decimal form to the CIDR form
        (netmask prefix).
        """

        i = 0
        integer = 0
        segments = netmask.split('.')

        for index, segment in enumerate(segments):
            integer += (int(segment) << (24 - (8 * index)))

        for b in bin(integer)[2:]:
            if b == '1':
                i += 1
            else:
                break

        return i


    def __init__(self, daemon, configuration_path):
        # Relevant global configuration.
        self.lib_dir = daemon.lib_dir
        self.fwbuilder_script_dir = daemon.fwbuilder_script_dir

        # Load the overlay configuration file.
        self.config = configparser.ConfigParser()
        self.config.read(configuration_path)

        # ipdb configuration. The network namespace ipdb gets loaded later.
        self.ipdb = None
        self.root_ipdb = daemon.ipdb

        # Check whether this overlay is enabled or not.
        if 'enabled' in self.config['overlay']:
            self.enabled = get_boolean(self.config['overlay']['enabled'])
        else:
            self.enabled = True

        # Generate the list of nodes, sorted numerically.
        nodes_dict = {}

        for key in self.config['overlay'].keys():
            if key.startswith('node-'):
                nodes_dict[int(key.lstrip('node-'))] = tuple(self.config['overlay'][key].split())

        self.nodes = [nodes_dict[key] for key in sorted(nodes_dict.keys())]

        # Get the node dictionary for this node from the list of nodes.
        self.this_node = next((node for node in self.nodes if node[0] == get_name(self.config['overlay']['this-node'])), None)

        # The name of the overlay. Also the name of the network namespace.
        self.name = get_name(self.config['overlay']['name'])
        self.netns_name = self.name

        # Used to configure the overlay's BGP routing system AS number. 
        self.asn = int(self.config['overlay']['asn'])

        # Used for determining the available /31 subnets for the mesh tunnels.
        self.linknet_pool = ipaddress.ip_network(self.config['overlay']['linknet-pool'])

        # Get the (absolute or relative) path to the fwbuilder script to
        # configure the firewall in this overlay.
        self.fwbuilder_script = self.config['overlay']['fwbuilder-script'] if 'fwbuilder-script' in self.config['overlay'] else None

        # Used to generate the configuration for the BIRD routing daemon.
        self.bird_config = {}
        self.bird_config_template = daemon.bird_config_template

        # Used by Overlay.interface_name().
        self.interface_names = daemon.interface_names

        # Used by Overlay.gre_key().
        self.mesh_tunnels = daemon.mesh_tunnels

        # self.static_vlans = defined in start_vlans()
        # self.static_tunnels = defined in start_tunnels()
        # self.static_veths = defined in start_veths()

        # Network namespace root directory. Used for saving network namespace
        # specific configuration files.
        self.netns_root = os.path.join(self.lib_dir, "netns", self.netns_name)

        # Sanity checks.
        if self.this_node is None:
            raise Exception("'%s' is missing from node list" % self.config['overlay']['this-node'])

        if len(self.nodes) != len(set(self.nodes)):
            raise Exception("node list contains a duplicate")

        # Initial operating state of the overlay.
        self.stopped = False

        # Start the overlay.
        self.start()


    def links(self):
        """
        Bi-directionally enumerate all of the links in a mesh, with each link's reverse immediately following it.
        """

        # The added nodes list stores the list of nodes with their links
        # already made in the list. Iterations of the list of nodes will 
        # make links to every node on on this added nodes list before
        # adding themselves to it for the next iteration.
        #
        # Creating links this way allows new nodes to be added without
        # affecting what the links() method previously generated. In other
        # words, when new hosts get added, their links get *appended* to the
        # end of the links list.

        links = []
        added_nodes = []

        for peer_node in self.nodes:
            peer_node_name = peer_node[0]
            peer_node_address = peer_node[1]

            for node_name, node_address in added_nodes:
                link = (node_name, peer_node_name)
                if node_name is not peer_node_name and link not in links and link[::-1] not in links:
                    links.append(link)
                    links.append(link[::-1])

            added_nodes.append(peer_node)

        return links


    def local_link_address(self, link):
        """
        Find the local address to give to a particular link.
        """

        return self.linknet_pool[0] + self.links().index(link)


    def interface_name(self, name, suffix=None, limit=15):
        """
        Creates a valid, unique (in this overlay daemon) interface name based
        on the given base name string, and returns it.
        """

        if_name_num = 0

        while True:
            digits = len(str(if_name_num))

            if suffix is not None:
                if_name_base = re.sub('[^A-Za-z0-9]', '', name)[:limit - len(suffix) - digits]
                if_name = "%s%s%i" % (if_name_base, suffix, if_name_num)
            else:
                if_name_base = re.sub('[^A-Za-z0-9]', '', name)[:limit - digits]
                if_name = "%s%i" % (if_name_base, if_name_num)

            if if_name not in self.interface_names:
                break

            if_name_num += 1

        self.interface_names.append(if_name)
        return if_name


    def interface_get(self, name, ipdb):
        """
        Tries to find an interface with the given name in the chosen ipdb
        and returns it. Throws an exception if it can't find it.
        """

        if name in ipdb.by_name.keys():
            interface = ipdb.interfaces[name]
        else:
            if ipdb == self.root_ipdb:
                raise Exception("unable to find interface %s in root namespace" % name)
            else:
                raise Exception("unable to find interface %s in network namespace" % name)

        return interface


    def interface_add_ip(self, interface, ip_tuple, ipdb):
        """
        Add the given IP address to the interface in the chosen ipdb.
        The IP tuple should be formatted like this: ('192.168.0.1', 24)
        """

        ip_string = "%s/%i" % ip_tuple

        if ip_tuple in interface.ipaddr:
            logging.debug("no need to add address %s to interface %s" % (ip_string, interface.ifname))
            return

        logging.debug("adding address %s to interface %s" % (ip_string, interface.ifname))

        interface.add_ip(ip_string)
        ipdb.commit()


    def interface_remove(self, interface=None, name=None, expr=None, ipdb=None):
        """
        Remove an interface, or any interface matching a given regular
        expression.

        The required arguments are an ipdb object, and one of an interface object, an interface name, or a matching regular expression.
        """

        if interface is not None:
            logging.debug("removing interface %s" % interface.ifname)

            interface.down()
            interface.remove()

            ipdb.commit()
        elif name is not None and ipdb is not None:
            if name in ipdb.by_name.keys():
                logging.debug("removing interface %s" % name)
                interface = ipdb.interfaces[name]

                interface.down()
                interface.remove()

                ipdb.commit()
        elif expr is not None and ipdb is not None:
            for name in ipdb.by_name.keys():
                if re.match(expr, name):
                    logging.debug("removing interface %s" % name)

                    interface = ipdb.interfaces[name]

                    interface.down()
                    interface.remove()

                    ipdb.commit()
        else:
            raise Exception("invalid arguments for interface_remove")


    def interface_up(self, interface, ipdb):
        """
        Bring up the given interface.
        """

        logging.debug("bringing up interface %s" % interface.ifname)
        interface.up()
        ipdb.commit()


    def bridge_create(self, name, ipdb):
        """
        Create a bridge interface with the given name in a chosen ipdb.
        Returns the interface entry from the ipdb.
        """

        if name not in ipdb.by_name.keys():
            logging.debug("creating bridge interface %s" % name)

            interface = ipdb.create(
                ifname=name,
                kind='bridge',
            )

            ipdb.commit()
        else:
            logging.debug("no need to create bridge interface %s" % name)
            interface = ipdb.interfaces[name]

        return interface


    def bridge_add_port(self, bridge, interface, ipdb):
        """
        Add the given interface to the list of ports for a given bridge.
        """

        if interface.index not in bridge.ports:
            logging.debug("adding interface %s to bridge %s" % (interface.ifname, bridge.ifname))
            bridge.add_port(interface)
            ipdb.commit()
        else:
            logging.debug("no need to add interface %s to bridge %s" % (interface.ifname, bridge.ifname))


    def gre_key(self, local, remote):
        """
        Generate a unique key value for the given (local, remote) address pair.
        """

        key = 0
        link = (local, remote)

        for l in self.mesh_tunnels:
            if l == link:
                key += 1

        return key


    def gre_create(self, name, local, remote, ipdb, kind='gre', ttl=16, key=None, ikey=None, okey=None, iflags=32, oflags=32):
        """
        Create a gre/gretap interface with the given name in a chosen ipdb.
        Returns the interface entry from the ipdb.
        """

        if key is not None:
            ikey = key
            okey = key

        if name in ipdb.by_name.keys():
            interface = ipdb.interfaces[name]

            if (interface.kind != kind or
                    interface.gre_local != local or
                    interface.gre_remote != remote or
                    interface.gre_ttl != ttl or
                    interface.gre_ikey != ikey or
                    interface.gre_okey != okey or
                    interface.gre_iflags != iflags or
                    interface.gre_oflags != oflags):
                raise Exception("existing interface with name %s with incorrect attributes, delete the existing interface manually and reload l3overlayd" % kind)
            else:
                logging.debug("no need to create %s tunnel %s" % (kind, name))
                return interface

        logging.debug("creating %s tunnel %s" % (kind, name))

        interface = ipdb.create(
            ifname=name,
            kind=kind,
            gre_local=local,
            gre_remote=remote,
            gre_ttl=ttl,
            gre_ikey=ikey,
            gre_okey=okey,
            gre_iflags=iflags,
            gre_oflags=oflags,
        )

        ipdb.commit()
        return interface


    def veth_create(self, name, peer, ipdb):
        """
        Create a veth pair with the given names in the chosen ipdb, and
        returns the root interface. The peer must be retrieved separately.
        """

        if name in ipdb.by_name.keys():
            interface = ipdb.interfaces[name]

            if interface.kind != 'veth':
                raise Exception("existing interface with name %s and not kind veth, delete the existing interface manually and reload l3overlayd" % name)
            else:
                logging.debug("no need to create veth pair %s and %s" % (name, peer))
                return interface

        logging.debug("creating veth pair %s and %s" % (name, peer))

        interface = ipdb.create(
            ifname=name,
            kind='veth',
            peer=peer,
        )

        ipdb.commit()
        return interface


    def vlan_create(self, name, link, id, ipdb):
        """
        Create a IEEE 802.1Q VLAN interface with the given name, physical link
        and ID in the chosen ipdb, and return the interface.
        """

        if name in ipdb.by_name.keys():
            interface = ipdb.interfaces[name]

            if (interface.kind != 'vlan' or
                    ipdb.by_index[interface.link] != link or
                    interface.vlan_id != id):
                raise Exception("existing interface with name %s with incorrect attributes, delete the existing interface manually and reload l3overlayd" % name)
            else:
                logging.debug("no need to create vlan interface %s" % name)
                return interface
        else:
            logging.debug("creating vlan interface %s" % name)

        interface = ipdb.create(
            ifname=name,
            kind='vlan',
            link=link,
            vlan_id=id,
        )

        ipdb.commit()
        return interface


    def netns_set(self, name, netns_name, netns_ipdb, ipdb):
        """
        Moves an interface into a chosen network namespace. Returns the
        interface object from the network namespace.
        """

        if name not in netns_ipdb.by_name.keys():
            logging.debug("moving interface %s to network namespace %s" % (name, netns_name))

            ipdb.interfaces[name].net_ns_fd = netns_name
            ipdb.commit()
        else:
            logging.debug("no need to move interface %s to network namespace %s" % (name, netns_name))

        return netns_ipdb.interfaces[name]


    def bird_config_add(self, key, value):
        """
        Add a variable to render to the BIRD configuration template.
        """

        logging.debug("adding variable %s to bird configuration" % key)
        self.bird_config[key] = value


    def start(self):
        """
        Start the overlay.
        """

        if self.enabled == False:
            return

        if self.stopped == True:
            raise Exception("cannot restart an Overlay after it has been stopped, create the Overlay object instead")

        self.start_namespace()
        self.start_mesh_tunnels()
        self.start_static_vlans()
        self.start_static_tunnels()
        self.start_static_veths()
        self.start_static_bgps()
        self.start_bird()
        self.start_firewall()


    def start_namespace(self):
        """
        Create the network namespace.
        """

        try:
            netns.create(self.netns_name)
        except FileExistsError:
            logging.debug("no need to create namespace '%s'" % self.netns_name)
        except:
            raise Exception("could not create namespace '%s'" % self.netns_name)
        else:
            logging.debug("created namespace '%s'" % self.netns_name)

        self.netns = NetNS(self.netns_name)
        self.ipdb = IPDB(nl=self.netns)

        # Create the network namespace root directory.
        os.makedirs(self.netns_root)


    def start_mesh_tunnels(self):
        """
        Create the mesh tunnels which connect the network namespaces on the
        nodes.
        """

        # The netns veth interfaces address one each of a mesh tunnel.
        # Each mesh tunnel is assigned a /31 subnet to address each end of the
        # tunnel.
        #
        # The range of addresses these /31 subnets are assigned from is defined
        # by the linknet_pool overlay configuration variable.
        linknet_pool_network = ipaddress.ip_network(self.linknet_pool)
        linknet_pool_address_base = linknet_pool_network.network_address
        linknet_pool_address_end = linknet_pool_network.broadcast_address

        # The list of mesh tunnels to add to the BIRD configuration, with their
        # IPsec encapsulations.
        gretaps = []
        ipsecs = []

        for index, link in enumerate(self.links()):
            # Check if this link requires a tunnel on this host. If not,
            # continue.
            if link[0] != self.this_node[0]:
                continue

            # Set some required data so the tunnel knows which direction it
            # needs to configure itself in.

            # Pair number. Increases for a change in nodes which are being
            # linked, rather than direction.
            pair_num = math.floor(index / 2)

            # Interface names.
            gretap_name = "m%il%i" % (self.asn, pair_num)
            ipsec_name = "%sip" % gretap_name
            bridge_name = "%sbr" % gretap_name
            root_veth_name = "%sv0" % gretap_name
            netns_veth_name = "%sv1" % gretap_name

            # IP addresses used for transit of the mesh tunnels.
            physical_local = None
            physical_remote = None

            for node, address in self.nodes:
                if node == link[0]:
                    physical_local = ipaddress.ip_address(address)
                elif node == link[1]:
                    physical_remote = ipaddress.ip_address(address)

                if physical_local is not None and physical_remote is not None:
                    break

            # Interface addresses for the mesh tunnel.
            netns_veth_address_local = linknet_pool_address_base + index
            netns_veth_address_local_tuple = (str(netns_veth_address_local), 31)

            netns_veth_address_remote = self.remote_address(netns_veth_address_local)

            # Make sure the number of assigned subnets does not overflow
            # the linknet pool.
            if netns_veth_address_local > linknet_pool_address_end or netns_veth_address_remote > linknet_pool_address_end:
                raise Exception("overflowed linknet pool %s with link %s" % (self.linknet_pool, str(link)))

            logging.debug("starting creation of mesh tunnel %s" % gretap_name)

            # Create the mesh tunnel interface.
            gretap_if = self.gre_create(
                name=gretap_name,
                kind='gretap',
                local=str(physical_local),
                remote=str(physical_remote),
                key=self.gre_key(physical_local, physical_remote),
                ipdb=self.root_ipdb,
            )

            # Create the tunnel's veth pair in the root namespace.
            root_veth_if = self.veth_create(
                name=root_veth_name,
                peer=netns_veth_name,
                ipdb=self.root_ipdb,
            )

            # Create a bridge interface.
            bridge_if = self.bridge_create(
                name=bridge_name,
                ipdb=self.root_ipdb,
            )

            # Add the root namespace veth interface and the mesh tunnel
            # interface to the bridge, linking them.
            self.bridge_add_port(
                bridge=bridge_if,
                interface=gretap_if,
                ipdb=self.root_ipdb,
            )

            self.bridge_add_port(
                bridge=bridge_if,
                interface=root_veth_if,
                ipdb=self.root_ipdb,
            )

            # Move one of the veth interfaces into the network namespace.
            netns_veth_if = self.netns_set(
                name=netns_veth_name,
                netns_name=self.netns_name,
                netns_ipdb=self.ipdb,
                ipdb=self.root_ipdb,
            )

            # Add an address to the network namespace veth interface, so it can
            # be addressed from either side of the mesh tunnel.
            self.interface_add_ip(
                interface=netns_veth_if,
                ip_tuple=netns_veth_address_local_tuple,
                ipdb=self.ipdb,
            )

            # Bring up all interfaces.
            self.interface_up(gretap_if, ipdb=self.root_ipdb)
            self.interface_up(root_veth_if, ipdb=self.root_ipdb)
            self.interface_up(bridge_if, ipdb=self.root_ipdb)
            self.interface_up(netns_veth_if, self.ipdb)

            # Add the mesh tunnel to the list of routed interfaces.
            logging.debug("adding bgp route for mesh tunnel %s" % gretap_name)

            gretaps.append({
                'interface': gretap_name,

                'local': {
                    'name': link[0],
                    'address': netns_veth_address_local,
                },

                'remote': {
                    'name': link[1],
                    'address': netns_veth_address_remote,
                },
            })

            # Add the local-remote link to the list of mesh tunnel links made.
            self.mesh_tunnels.append((physical_local, physical_remote))

            logging.debug("finished creation of mesh tunnel %s" % gretap_name)

        self.bird_config_add(key='gretaps', value=gretaps)


    def start_static_vlans(self):
        """
        Create a static VLAN between a physical interface on the node and the
        network namespace.
        """

        # The list of static VLANs to add to the BIRD configuration.
        self.static_vlans = []

        for section in self.config.sections():
            if section.startswith('static-vlan'):
                name = get_name(section.lstrip('static-vlan:'))
                id = int(self.config[section]['id'])
                physical_interface = get_name(self.config[section]['physical-interface'])
                netmask = self.config[section]['netmask']
                address = self.config[section]['address']

                vlan_name = self.interface_name(name=name, suffix='vl', limit=13)
                root_veth_name = "%sv0" % vlan_name
                netns_veth_name = "%sv1" % vlan_name
                bridge_name = "%sbr" % vlan_name

                address_tuple = (address, self.netmask_dd_to_cidr(netmask))

                # Find the physical interface in the IPDB.
                physical_if = self.interface_get(
                    physical_interface,
                    ipdb=self.root_ipdb,
                )

                # Create the VLAN interface.
                vlan_if = self.vlan_create(
                    name=vlan_name,
                    link=self.root_ipdb.interfaces[physical_interface],
                    id=id,
                    ipdb=self.root_ipdb,
                )

                # Create the veth pair.
                root_veth_if = self.veth_create(
                    name=root_veth_name,
                    peer=netns_veth_name,
                    ipdb=self.root_ipdb,
                )

                # Move the netns veth interface to the network namespace.
                netns_veth_if = self.netns_set(
                    name=netns_veth_name,
                    netns_name=self.netns_name,
                    netns_ipdb=self.ipdb,
                    ipdb=self.root_ipdb,
                )

                # Add the assigned address for the VLAN to the netns veth
                # interface.
                self.interface_add_ip(
                    interface=netns_veth_if,
                    ip_tuple=address_tuple,
                    ipdb=self.ipdb,
                )

                # Create a bridge for the physical interface to connect to the
                # network namespace via the veth pair.
                bridge_if = self.bridge_create(
                    name=bridge_name,
                    ipdb=self.root_ipdb,
                )

                # Add the physical interface and the root veth interface to the
                # bridge.
                self.bridge_add_port(
                    bridge=bridge_if,
                    interface=vlan_if,
                    ipdb=self.root_ipdb,
                )

                self.bridge_add_port(
                    bridge=bridge_if,
                    interface=root_veth_if,
                    ipdb=self.root_ipdb,
                )

                # Finally, we're done! Bring up the interfaces!
                self.interface_up(physical_if, ipdb=self.root_ipdb)
                self.interface_up(vlan_if, ipdb=self.root_ipdb)
                self.interface_up(root_veth_if, ipdb=self.root_ipdb)
                self.interface_up(netns_veth_if, self.ipdb)
                self.interface_up(bridge_if, ipdb=self.root_ipdb)

                # Add the veth interface connected to the VLAN to the list of 
                # routed interfaces.
                logging.debug("adding bgp route for static vlan %s" % name)
                self.static_vlans.append({
                    'name': name,
                    'interface': netns_veth_name,
                    'vlan_interface': vlan_name,
                    'root_interface': root_veth_name,
                    'bridge_interface': bridge_name,
                })

                logging.debug("finished creation of static vlan %s" % name)

        self.bird_config_add(key='vlans', value=self.static_vlans)


    def start_static_tunnels(self):
        """
        Create a static GRE or gretap tunnel in the network namespace.
        """

        # The list of static tunnels to add to the BIRD configuration.
        self.static_tunnels = []

        for section in self.config.sections():
            if section.startswith('static-tunnel'):
                name = get_name(section.lstrip('static-tunnel:'))
                mode = self.config[section]['mode']
                local = self.config[section]['local']
                remote = self.config[section]['remote']
                netmask = self.config[section]['netmask']
                address = self.config[section]['address']

                tunnel_name = self.interface_name(name)

                address_tuple = (address, self.netmask_dd_to_cidr(netmask))

                logging.debug("starting creation of static tunnel %s" % name)

                tunnel_if = self.gre_create(
                    name=tunnel_name,
                    kind=mode,
                    local=local,
                    remote=remote,
                    key=self.gre_key(local, remote),
                    ipdb=self.ipdb,
                )

                self.interface_add_ip(
                    interface=tunnel_if,
                    ip_tuple=address_tuple,
                    ipdb=self.ipdb,
                )

                self.interface_up(tunnel_if, ipdb=self.ipdb)

                # Add the tunnel to the list of routed interfaces.
                logging.debug("adding bgp route for static tunnel %s" % name)
                self.static_tunnels.append({
                    'name': name,
                    'interface': tunnel_name,
                })

                logging.debug("finished creation of static tunnel %s" % name)

        self.bird_config_add(key='tunnels', value=self.static_tunnels)


    def start_static_veths(self):
        """
        Create a static veth pair between the network namespace and the root
        namespace.
        """

        # The list of static veths to add to the BIRD configuration.
        self.static_veths = []

        for section in self.config.sections():
            if section.startswith('static-veth'):
                name = get_name(section.lstrip('static-veth:'))
                netmask = self.config[section]['netmask']
                inner_address = self.config[section]['inner-address']
                outer_address = self.config[section]['outer-address']

                netmask_cidr = self.netmask_dd_to_cidr(netmask)

                outer_name = self.interface_name(name + 'v')
                inner_name = self.interface_name(name + 'v')

                outer_address_tuple = (outer_address, netmask_cidr)
                inner_address_tuple = (inner_address, netmask_cidr)

                logging.debug("starting creation of static veth %s" % name)

                outer_if = self.veth_create(
                    name=outer_name,
                    peer=inner_name,
                    ipdb=self.root_ipdb,
                )

                # Move the inner interface into the network namespace. The idea
                # of a static veth is that it creates a static path between the
                # root and network namespaces.
                inner_if = self.netns_set(
                    name=inner_name,
                    netns_name=self.netns_name,
                    netns_ipdb=self.ipdb,
                    ipdb=self.root_ipdb,
                )

                self.interface_add_ip(
                    interface=outer_if,
                    ip_tuple=outer_address_tuple,
                    ipdb=self.root_ipdb,
                )

                self.interface_add_ip(
                    interface=inner_if,
                    ip_tuple=inner_address_tuple,
                    ipdb=self.ipdb,
                )

                self.interface_up(outer_if, ipdb=self.root_ipdb)
                self.interface_up(inner_if, ipdb=self.ipdb)

                # Add the inner interface to the list of routed interfaces.
                logging.debug("adding bgp route for static veth %s" % name)
                self.static_veths.append({
                    'name': name,
                    'interface': inner_name,
                    'outer_interface': outer_name,
                })

                logging.debug("finished creation of static veth %s" % name)

        self.bird_config_add(key='veths', value=self.static_veths)


    def start_static_bgps(self):
        """
        Create a static BGP protocol in the network namespace.
        """

        # The list of static BGP protocols to add to the BIRD configuration.
        bgps = []

        for section in self.config.sections():
            if section.startswith('static-bgp'):
                bgp = {}
                name = get_name(section.lstrip('static-bgp:'))

                logging.debug("adding static bgp %s to bird configuration" % name)

                bgp['name'] = name
                bgp['local_asn'] = int(self.config[section]['local-asn'])
                bgp['neighbor'] = self.config[section]['neighbor']
                bgp['neighbor_asn'] = int(self.config[section]['neighbor-asn'])

                if 'description' in self.config[section]:
                    bgp['description'] = self.config[section]['description']

                if 'local' in self.config[section]:
                    bgp['local'] = self.config[section]['local']

                # The import prefixes is a list of IP address subnets to filter
                # the BGP protocol's import function against.
                import_prefixes = []
                for key in self.config[section].keys():
                    if key.startswith('import-prefix'):
                        import_prefixes.append(self.config[section][key])

                if len(import_prefixes) > 0:
                    bgp['import_prefixes'] = import_prefixes

                bgps.append(bgp)

        self.bird_config_add(key='bgps', value=bgps)


    def start_bird(self):
        """
        Configure and start the BIRD routing daemon.
        """

        bird_config_dir = os.path.join(self.netns_root, "etc", "bird")
        bird_config_file = os.path.join(bird_config_dir, "bird.conf")

        bird_socket_dir = os.path.join(self.netns_root, "run", "bird")
        bird_socket_file = os.path.join(bird_socket_dir, "bird.ctl")
        bird_pid_file = os.path.join(bird_socket_dir, "bird.pid")

        # Create the required BIRD directories.
        if not os.path.exists(bird_config_dir):
            logging.debug("creating bird configuration directory")
            os.makedirs(bird_config_dir)
        else:
            logging.debug("no need to create bird configuration directory")

        if not os.path.exists(bird_socket_dir):
            logging.debug("creating bird socket directory")
            os.makedirs(bird_socket_dir)
        else:
            logging.debug("no need to create bird socket directory")

        logging.debug("starting configuration of the bird routing daemon")

        # Add required parameters to the BIRD configuration.
        self.bird_config_add(key='netns', value=self.netns_name)
        self.bird_config_add(key='asn', value=self.asn)

        # Save the BIRD configuration.
        logging.debug("saving bird configuration to disk")

        f = open(bird_config_file, 'w')
        f.write(self.bird_config_template.render(self.bird_config))
        f.close()

        logging.debug("finished configuration of the bird routing daemon")

        # If there is a BIRD daemon already running, connect to its socket and
        # tell it to reload its configuration.
        if os.path.exists(bird_socket_file):
            try:
                sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                sock.connect(bird_socket_file)
                sock.send(bytes("configure \"%s\"\n" % bird_config_file, 'UTF-8'))

                logging.debug("reloading the bird routing daemon")

                response = ''

                datagram = sock.recv(1024)
                response = datagram.decode('UTF-8')

                if "0002-Reading configuration from %s" % bird_config_file not in response or ("0003 Reconfigured" not in response and "0004 Reconfiguration in progress" not in response):
                    raise Exception("unable to reload bird configuration. output:\n%s" % response)

                sock.close()
                logging.debug("finished reloading the bird routing daemon")
                return
            except socket.error as e:
                if e.errno != errno.ECONNREFUSED:
                    raise
               
        # If not, then start a new BIRD daemon. 
        logging.debug("starting the bird routing daemon")

        try:
            ip = find_executable("ip")
            bird = find_executable("bird")

            if ip is None:
                raise Exception("cannot find ip (iproute2) executable path")

            if bird is None:
                raise Exception("cannot find bird executable path")

            subprocess.check_output([
                ip, "netns", "exec", self.netns_name,
                bird,
                    "-c", bird_config_file,
                    "-s", bird_socket_file,
                    "-P", bird_pid_file,
            ], stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            logging.error("error detected in process call:\n%s" % e.output.decode('UTF-8'))
            raise

        logging.debug("finished starting the bird routing daemon")


    def start_firewall(self):
        """
        Run the fwbuilder script in the network namespace.
        """

        if self.fwbuilder_script is not None:
            logging.debug("building firewall for namespace %s" % self.netns_name)

            try:
                ip = find_executable("ip")

                if ip is None:
                    raise Exception("cannot find ip (iproute2) executable path")

                if os.path.isabs(self.fwbuilder_script):
                    command = self.fwbuilder_script
                else:
                    command = os.path.join(self.fwbuilder_script_dir, self.fwbuilder_script)

                subprocess.check_output([
                    ip, "netns", "exec", self.netns_name,
                    command,
                ], stderr=subprocess.STDOUT)
            except subprocess.CalledProcessError as e:
                logging.error("error detected in process call:\n%s" % e.output.decode('UTF-8'))
                raise


    def stop(self):
        """
        Stop the overlay.
        """

        if self.enabled == False:
            return

        # Ensure this Overlay object cannot be restarted.
        self.stopped = True

        # Already removed because it is entirely contained in the network namespace.
        # self.stop_firewall()
        self.stop_bird()
        # Already removed because it is entirely contained in BIRD.
        # self.stop_static_bgps()
        self.stop_static_veths()
        self.stop_static_tunnels()
        self.stop_static_vlans()
        self.stop_mesh_tunnels()
        self.stop_namespace()


    def stop_namespace(self):
        """
        Delete the network namespace.
        """

        logging.debug("removing namespace %s" % self.netns_name)

        logging.debug("releasing the IPDB for namespace %s" % self.netns_name)
        self.ipdb.release()

        logging.debug("closing the netns for namespace %s" % self.netns_name)
        self.netns.close()

        logging.debug("removing the netns for namespace %s" % self.netns_name)
        netns.remove(self.netns_name)

        logging.debug("removing the netns root tree for namespace %s" % self.netns_name)
        shutil.rmtree(self.netns_root)

        logging.debug("removed namespace %s" % self.netns_name)


    def stop_mesh_tunnels(self):
        """
        Destroy the root namespace components of the mesh tunnels.
        """

        logging.debug("starting destruction of mesh tunnels")

        self.interface_remove(
            expr="^m%il[0-9][0-9]*br$" % self.asn,
            ipdb=self.root_ipdb,
        )

        self.interface_remove(
            expr="^m%il[0-9][0-9]*v0$" % self.asn,
            ipdb=self.root_ipdb,
        )

        self.interface_remove(
            expr="^m%il[0-9][0-9]*$" % self.asn,
            ipdb=self.root_ipdb,
        )

        logging.debug("finished destruction of mesh tunnels")


    def stop_static_tunnels(self):
        """
        Destroy the static tunnels.
        """

        for tunnel in self.static_tunnels:
            name = tunnel['name']
            tunnel_name = tunnel['interface']

            logging.debug("starting destruction of static tunnel %s" % name)

            self.interface_remove(
                name=tunnel_name,
                ipdb=self.ipdb,
            )

            logging.debug("finished destruction of static tunnel %s" % name)


    def stop_static_vlans(self):
        """
        Destroy the root namespace components of the static VLANs.
        """

        for vlan in self.static_vlans:
            name = vlan['name']

            logging.debug("starting destruction of static vlan %s" % name)

            self.interface_remove(
                name=vlan['bridge_interface'],
                ipdb=self.root_ipdb,
            )

            self.interface_remove(
                name=vlan['root_interface'],
                ipdb=self.root_ipdb,
            )

            self.interface_remove(
                name=vlan['vlan_interface'],
                ipdb=self.root_ipdb,
            )

            logging.debug("finished destruction of static vlan %s" % name)


    def stop_static_veths(self):
        """
        Destroy the root namespace components of the static veth pairs.
        """

        for veth in self.static_veths:
            name = veth['name']

            logging.debug("starting destruction of static veth %s" % name)

            self.interface_remove(
                name=veth['outer_interface'],
                ipdb=self.root_ipdb,
            )

            logging.debug("finished destruction of static veth %s" % name)


    def stop_bird(self):
        """
        Stop the BIRD routing daemon. The configuration gets destroyed when
        the network namespace root directory gets cleaned up.
        """

        f = open(os.path.join(self.netns_root, "run", "bird", "bird.pid"))
        pid = int(f.read())

        logging.debug("stopping the bird routing daemon")

        os.kill(pid, signal.SIGTERM)

        logging.debug("stopped the bird routing daemon")


def get_boolean(value):
    """
    Get a boolean value from a string. Raise an exception if the string
    is not a valid boolean.
    """

    lower_value = value.lower()

    if lower_value != "true" and lower_value != "false":
        raise Exception("invalid value for boolean: %s" % lower_value)

    return True if lower_value == "true" else False


def get_name(value):
    """
    Check that a string is a valid name, and return it. A name is a string
    that is just one word, without whitespace. Raise an exception if the string
    is not a valid name.
    """

    name = value.strip()

    if len(name) == 0:
        raise Exception("empty string not a valid name")

    if not re.fullmatch("[^\s][^\s]*", value):
        raise Exception("given string not a valid name (contains whitespace): %s" % name)

    return name


def get_hex_string(value, min=None, max=None):
    """
    Check that a string is a valid hexadecimal integer, optionally checking if
    it is within a minimum and maximum length. Returns the string if the
    conditions are satisfied, raises an exception otherwise.
    """

    length = len(value)

    if length == 0:
        raise Exception("empty string not a valid hexadecimal integer")

    if min is not None and length < min:
        raise Exception("hexadecimal integer too short, minimum %i digits required: %s" % (min, value))

    if max is not None and length > max:
        raise Exception("hexadecimal integer too long, maximum %i digits required: %s" % (max, value))

    if not re.fullmatch("[0-9A-Fa-f][0-9A-Fa-f]*", value):
        raise Exception("given string not a valid hexadecimal integer: %s" % value)

    return value


def my_path():
    """
    Return the directory containing this script.
    """

    return os.path.dirname(os.path.realpath(sys.argv[0]))


def root_path():
    """
    Return the operating system root directory. System independent.
    """

    return os.path.abspath(os.sep)


def get_path(filename, paths):
    """
    Returns the first instance of a valid filepath, made from the given 
    filename joined with each element from the list of paths. If it doesn't
    find a match, returns the final filepath combination from the list.

    Works with both files and directories, but does not distinguish them.
    """

    for path in paths:
        filepath = os.path.join(path, filename)
        if (os.path.exists(filepath)):
            return filepath

    return filepath


def pid_exists(pid):
    """
    Checks for the existence of a PID on the running system.
    """

    if pid <= 0:
        raise ValueError("invalid PID: %i" % pid)

    try:
        os.kill(pid, 0)
    except OSError as e:
        # ESRCH = No such process
        if e.errno == errno.ESRCH:
            return False
        # EPERM = Permission denied
        # A process clearly exists if we don't have access to it.
        elif e.errno == errno.EPERM:
            return True
        # EINVAL = Invalid signal
        # Something went wrong.
        else:
            raise
    # No exception - process exists
    else:
        return True


def close_overlays(signum, frame):
    """
    Shut down all overlays and IPsec tunnels and clean up and temporary files
    before exiting.
    """

    daemon.shutdown()
    os.remove(pid_file)

    sys.exit(0)


def reload_overlays(signum, frame):
    """
    Stop the OverlayDaemon, reload the configuration, and restart it.
    """

    logging.info("Restarting daemon...")

    daemon.stop()
    daemon.start()

    logging.info("Restarted.")


if __name__ == "__main__":
    # Define the search paths. Search for configuration files in the
    # following locations, in this order:
    # 1. (current working directory)
    # 2. (current working directory)/etc/l3overlay
    # 3. (current working directory)/../etc/l3overlay
    # 4. (executable directory)
    # 5. (executable directory)/etc/l3overlay
    # 6. (executable directory)/../etc/l3overlay
    # 7. /etc/l3overlay
    paths = [
        os.getcwd(),
        os.path.join(os.getcwd(), "etc", "l3overlay"),
        os.path.join(os.getcwd(), "..", "etc", "l3overlay"),
        my_path(),
        os.path.join(my_path(), "etc", "l3overlay"),
        os.path.join(my_path(), "..", "etc", "l3overlay"),
        os.path.join(root_path(), "etc", "l3overlay"),
    ]

    lib_dir = os.path.join(root_path(), "var", "lib", "l3overlay")
    run_dir = os.path.join(root_path(), "var", "run")

    # Use the path list to search for these files and directories.
    template_dir = get_path("templates", paths)

    global_conf = get_path("global.conf", paths)
    overlay_conf_dir = get_path("overlays", paths)

    fwbuilder_script_dir = get_path("fwbuilder_scripts", paths)

    pid_file = os.path.join(run_dir, "l3overlayd.pid")

    # Parse optional arguments, and return the final values which will be used
    # in l3overlayd configuration.
    argparser = argparse.ArgumentParser(description="Construct one or more MPLS-like VRF networks using IPsec tunnels and network namespaces.")

    argparser.add_argument(
        '--global-conf',
        metavar='FILE',
        type=str,
        default=global_conf,
        help="use FILE as the global configuration file",
    )

    argparser.add_argument(
        '--overlay-conf-dir',
        metavar='DIR',
        type=str,
        default=overlay_conf_dir,
        help="use DIR as the overlay conf search directory",
    )

    argparser.add_argument(
        '--fwbuilder-script-dir',
        metavar='DIR',
        type=str,
        default=fwbuilder_script_dir,
        help="use DIR as the fwbuilder script search directory",
    )

    argparser.add_argument(
        '--overlay-conf',
        metavar='FILE',
        type=str,
        nargs='+',
        default=None,
        help="configure the overlay defined in FILE",
    )

    args = argparser.parse_args()

    # Look for an existing l3overlayd PID file lock. If there is one and the
    # PID actually exists, shut down this instance and warn the user. If there
    # is a PID file and it doesn't contain a valid process, remove the PID lock
    # and start anyway.
    if os.path.exists(pid_file):
        f = open(pid_file, 'r')
        pid_file_data = f.read().strip()
        f.close()

        if len(pid_file_data) > 0 and re.match("[0-9][0-9]*", pid_file_data):
            pid_file_pid = int(pid_file_data)

            if pid_exists(pid_file_pid):
                raise RuntimeError("valid PID lock file found with PID %i, to start a new l3overlayd instance, kill the running l3overlayd instance with this PID" % pid_file_pid)
        else:
            os.remove(pid_file)

    # Find all available overlay configuration files, and build those overlays.
    overlay_paths = []

    for overlay in os.listdir(args.overlay_conf_dir):
        overlay_path = os.path.join(args.overlay_conf_dir, overlay)
        if os.path.isfile(overlay_path):
            overlay_paths.append(overlay_path)

    if args.overlay_conf is not None:
        for overlay_path in args.overlay_conf:
            overlay_paths.append(overlay_path)

    # Launch a new OverlayDaemon, which takes in all of the configured data and
    # starts/stops the overlays.
    daemon = OverlayDaemon(
        template_dir=template_dir,
        lib_dir=lib_dir,
        global_conf=args.global_conf,
        fwbuilder_script_dir=args.fwbuilder_script_dir,
        overlay_paths=overlay_paths,
    )

    # Invoke the shutdown routine when receiving the SIGTERM signal.
    signal.signal(signal.SIGTERM, close_overlays)

    # Invoke the reload routine when receiving the SIGHUP signal.
    signal.signal(signal.SIGHUP, reload_overlays)

    # Save the PID of this daemon to a file. This serves as a lock for
    # l3overlayd, and allows it to be monitored by external processes.
    f = open(pid_file, 'w')
    f.write("%i\n" % os.getpid())
    f.close()

    os.chmod(pid_file, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH)

    # The daemon is now started. Wait until we receive a signal.
    signal.pause()
