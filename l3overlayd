#!/usr/bin/env python3
#
# Copyright (c) 2016 Catalyst.net Ltd
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import argparse
import configparser
import errno
import hashlib
import ipaddress
import logging
import math
import os
import re
import shutil
import signal
import socket
import stat
import subprocess
import sys
import time

from distutils.spawn import find_executable

from jinja2 import Environment
from jinja2 import FileSystemLoader

from pyroute2 import IPDB
from pyroute2 import netns
from pyroute2 import NetNS

class OverlayDaemon(object):
    """
    Configures the overlay daemon, and manages all enabled overlays.
    """

    def __init__(self, template_dir, lib_dir, log_file, global_conf, fwbuilder_script_dir, overlay_paths):

        # Directory which stores configuration templates.
        self.template_dir = template_dir

        # Directory for l3overlayd state information.
        self.lib_dir = lib_dir

        # Daemon log file.
        self.log_file = log_file

        # Filepath for the global configuration file.
        self.global_conf = global_conf

        # Directory for fwbuilder scripts.
        self.fwbuilder_script_dir = fwbuilder_script_dir

        # Filepaths to the overlay configuration files.
        self.overlay_paths = tuple(overlay_paths)

        # Initial state for an OverlayDaemon is stopped, and NOT shut down.
        self.stopped = True
        self.shut_down = False

        # Root namespace IPDB. Ideally, this would be loaded in config_load(),
        # but IPDB's weren't designed to be started and stopped more than once
        # in an instance.
        self.ipdb = IPDB()

        # OverlayDaemon starting routine.
        self.start()


    @staticmethod
    def _overlay_paths_sorted(overlays, overlay_names_to_paths, sorted_overlay_paths, name):
        """
        Add an overlay configuration file path to the list of sorted overlay
        paths, while adding any overlays that the overlay depends on before it.
        """

        overlay = overlays[name]
        path = overlay_names_to_paths[name]

        if path in sorted_overlay_paths:
            return

        for section in overlay.sections():
            if section.startswith('static-veth') and 'outer-namespace' in overlay[section]:
                outer_namespace = Util.name_get(overlay[section]['outer-namespace'])

                if outer_namespace in overlays:
                    OverlayDaemon._overlay_paths_sorted(
                        overlays,
                        overlay_names_to_paths,
                        sorted_overlay_paths,
                        outer_namespace)
            elif section.startswith('static-overlay-link'):
                inner_overlay_name = Util.name_get(overlay[section]['inner-overlay-name'])

                if inner_overlay_name in overlays:
                    OverlayDaemon._overlay_paths_sorted(
                        overlays,
                        overlay_names_to_paths,
                        sorted_overlay_paths,
                        inner_overlay_name)
                else:
                    raise ValueError("no overlay configured with name %s, required by inner-overlay-name in [%s] for overlay %s" % (inner_overlay_name, section, name))

        sorted_overlay_paths.append(path)


    @staticmethod
    def overlay_paths_sorted(overlay_paths):
        """
        Return a list of overlay configuration file paths, where the elements
        are sorted such that if the overlays are loaded in that order, there
        will be no issues with inter-overlay dependencies, such as a
        static-veth overlay link.
        """

        overlays = {}
        overlay_names_to_paths = {}
        sorted_overlay_paths = []

        # Pass 1: load overlay configurations, map overlay names to overlay
        # file paths.
        for path in overlay_paths:
            overlay = configparser.ConfigParser()
            overlay.read(path)

            overlays[overlay['overlay']['name']] = overlay
            overlay_names_to_paths[overlay['overlay']['name']] = path

        # Pass 2: add each overlay to the list of sorted overlay paths,
        # using a recursive function to resolve dependencies.
        for name in overlay_names_to_paths:
            OverlayDaemon._overlay_paths_sorted(
                overlays,
                overlay_names_to_paths,
                sorted_overlay_paths,
                name)

        return tuple(sorted_overlay_paths)


    def start(self):
        """
        Start this OverlayDaemon, and all of its configured overlays.
        """

        if self.shut_down == True:
            raise Exception("OverlayDaemon permanently shut down, cannot start again")

        if self.stopped == False:
            return

        self.stopped = False

        # Load the runtime configuration data.
        self.start_config()

        # Configure the logging system.
        self.start_logging()

        # This is the point where building the OverlayDaemon starts.
        logging.info("Starting daemon...")

        # Create the runtime directories.
        self.start_directories()

        # Start all of the configured overlays, respecting any inter-overlay
        # dependencies.
        for overlay_path in OverlayDaemon.overlay_paths_sorted(self.overlay_paths):
            self.overlays.append(Overlay(self, overlay_path))

        # Start the IPsec tunnels for the overlays.
        self.start_ipsec()

        logging.info("Started.")


    def start_config(self):
        """
        Load the runtime configuration for this OverlayDaemon.
        """

        # Load the global configuration file.
        if os.path.exists(self.global_conf):
            config = configparser.ConfigParser()
            config.read(self.global_conf)

            self.config_env = Environment(
                trim_blocks=True,
                loader=FileSystemLoader(template_dir),
            )
        else:
            config = {'global': {}}

        # Logging level.
        if 'logging-level' in config['global']:
            self.logging_level = Util.enum_get(
                config['global']['logging-level'],
                [ 'NOSET', 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL' ],
            )
        else: 
            self.logging_level = logging.INFO

        # Check whether or not to use IPsec.
        if 'use-ipsec' in config['global']:
            self.use_ipsec = Util.boolean_get(config['global']['use-ipsec'])
        else:
            self.use_ipsec = False

        # IPsec PSK, to be configured onto all tunnels.
        self.ipsec_psk = Util.hex_get_string(config['global']['ipsec-psk'], min=6, max=64) if self.use_ipsec == True else None

        # Determine whether or not to take over control of IPsec. Read the
        # README for more information on how this option works.
        if 'use-ipsec' in config['global']:
            self.ipsec_manage = Util.boolean_get(config['global']['ipsec-manage']) if 'ipsec-manage' in config['global'] else True
        else:
            self.ipsec_manage = False

        #
        # Find external files needed in overlay configuration.
        #

        # Used to generate the BIRD routing daemon configurations.
        self.bird_config_template = self.config_env.get_template('bird.conf')

        # Used to generate the IPsec tunnel configuration.
        self.ipsec_config_template = self.config_env.get_template('ipsec.conf')
        self.ipsec_secrets_template = self.config_env.get_template('ipsec.secrets')

        #
        # Runtime data structures and objects.
        #

        # Used by Overlay.interface_name() to store the interface names already
        # generated by itself, so it can generate a unique one in the next run.
        self.interface_names = []

        # List of mesh tunnel links that have been made, and how many times
        # they have been made (by allowing duplicates in the list).
        #
        # Used by Overlay.gre_key() to store the amount of times a specific
        # link has been used to create a GRE tunnel, so it can return a unique
        # key for the next one.
        #
        # Also used by start_ipsec() and stop_ipsec() to generate the IPsec
        # tunnels that are used to encapsulate the GRE tunnels.
        self.mesh_tunnel_links = []

        # List of overlays.
        self.overlays = []

        # IPsec directories and files.
        if self.use_ipsec == True:
            if self.ipsec_manage == True:
                self.ipsec_config_dir = os.path.join(Util.path_root(), "etc")
                self.ipsec_config_file = os.path.join(self.ipsec_config_dir, "ipsec.conf")
            else:
                self.ipsec_config_dir = os.path.join(Util.path_root(), "etc", "ipsec.d")
                self.ipsec_config_file = os.path.join(self.ipsec_config_dir, "l3overlay.conf")

            self.ipsec_secrets_dir = os.path.join(Util.path_root(), "etc")

            self.ipsec_secrets_stub_file = os.path.join(self.ipsec_secrets_dir, "ipsec.secrets")
            self.ipsec_secrets_file = os.path.join(self.ipsec_secrets_dir, "ipsec.l3overlay.secrets")


    def start_logging(self):
        """
        Configure the logging system.
        """

        logging.basicConfig(
            level=self.logging_level,
            handlers=[
                logging.FileHandler(self.log_file),
                logging.StreamHandler(),
            ],
        )


    def start_directories(self):
        """
        Create the runtime directories for this OverlayDaemon, securely, with
        the correct umask.
        """

        # Set the umask so that any files that this OverlayDaemon creates, will
        # only be readable and writable by itself.
        logging.debug("setting up file and directory handling")

        logging.debug("setting umask")
        os.umask(
            stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP |
            stat.S_IROTH | stat.S_IWOTH | stat.S_IXOTH
        )

        # Create directories.
        logging.debug("creating %s" % self.lib_dir)
        Util.directory_create(self.lib_dir)

        logging.debug("finished setting up file and directory handling")


    def start_ipsec(self):
        """
        Configure and start the strongSwan IPsec tunnel daemon, if enabled.
        """

        if self.use_ipsec == False:
            return

        logging.debug("setting up IPsec daemon management")

        # Create the IPsec config directory.
        logging.debug("creating IPsec configuration directory")
        Util.directory_create(self.ipsec_config_dir)

        # Start doing everything needed to start IPsec.
        logging.debug("configuring ipsec")

        # Save the IPsec configuration.
        logging.debug("saving ipsec configuration to disk")

        with open(self.ipsec_config_file, 'w') as f:
            f.write(self.ipsec_config_template.render(
                file=self.ipsec_config_file,
                mesh_tunnel_links=self.mesh_tunnel_links,
            ))

        # Create the directory where the IPsec secrets are stored.
        logging.debug("creating IPsec secrets directory")
        Util.directory_create(self.ipsec_secrets_dir)

        # This file includes the REAL IPsec secrets file which gets created
        # by l3overlay. Only gets created if ipsec_manage is true.
        if self.ipsec_manage == True:
            logging.debug("saving IPsec secrets stub file to disk")

            with open(self.ipsec_secrets_stub_file, 'w') as f:
                f.write("include %s\n" % self.ipsec_secrets_file)

        # Save the REAL ipsec.secrets.
        logging.debug("saving IPsec secrets file to disk")

        addresses = []

        for local, remote in self.mesh_tunnel_links:
            if local not in addresses:
                addresses.append(local)

            if remote not in addresses:
                addresses.append(remote)

        with open(self.ipsec_secrets_file, 'w') as f:
            f.write(self.ipsec_secrets_template.render(
                file=self.ipsec_secrets_file,
                addresses=addresses,
                secret=self.ipsec_psk,
            ))

        logging.debug("finished configuring ipsec")

        # Start IPsec, or, if it is already running, reload the configuration.
        try:
            ipsec = find_executable("ipsec")

            if ipsec is None:
                raise Exception("cannot find ipsec executable path")

            status = subprocess.call(
                [ipsec, "status"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )

            if status == 0:
                logging.debug("reloading IPsec")

                logging.debug("reloading IPsec secrets")
                subprocess.check_output(
                    [ipsec, "rereadsecrets"],
                    stderr=subprocess.STDOUT,
                )

                logging.debug("reloading IPsec configuration")
                subprocess.check_output(
                    [ipsec, "reload"],
                    stderr=subprocess.STDOUT,
                )

                logging.debug("finished reloading IPsec")
            elif status == 3:
                logging.debug("starting IPsec")

                subprocess.check_output(
                    [ipsec, "start"],
                    stderr=subprocess.STDOUT,
                )

                logging.debug("finished starting IPsec")
            else:
                raise Exception("unexpected return code for ipsec, status %i" % status)
        except subprocess.CalledProcessError as e:
            logging.error("error detected in process call:\n%s" % e.output.decode('UTF-8'))
            raise

        logging.debug("finished setting up IPsec daemon management")


    def stop(self):
        """
        Shut down all overlays in OverlayDaemon. Once an OverlayDaemon is
        stopped, it cannot be restarted.
        """

        if self.stopped == True:
            return

        self.stopped = True

        logging.info("Stopping daemon...")

        daemon.stop_ipsec()

        # Reverse the list of overlays in order to unload overlays
        # in the opposite order of loading.
        for overlay in reversed(self.overlays):
            overlay.stop()

        daemon.stop_directories()
        logging.info("Stopped.")


    def stop_directories(self):
        """
        Destroy the runtime directories.

        This should be fine, because at this point, there should be no required
        files in the runtime directories.
        """

        logging.debug("removing %s" % self.lib_dir)
        shutil.rmtree(self.lib_dir)


    def stop_ipsec(self):
        """
        Stop the strongSwan IPsec tunnel daemon, and destroy the configuration,
        if enabled.
        """

        if self.use_ipsec == False:
            return

        logging.debug("stopping IPsec daemon management")

        logging.debug("removing IPsec configuration")
        os.remove(self.ipsec_config_file)

        if self.ipsec_manage == True:
            logging.debug("removing IPsec secrets stub file")
            os.remove(self.ipsec_secrets_stub_file)

        logging.debug("removing IPsec secrets file")
        os.remove(self.ipsec_secrets_file)

        try:
            ipsec = find_executable("ipsec")

            if ipsec is None:
                raise Exception("cannot find IPsec executable path")

            if self.ipsec_manage == True:
                # When we manage IPsec, it is safe to stop it completely.
                logging.debug("stopping IPsec")

                subprocess.check_output(
                    [ipsec, "stop"],
                    stderr=subprocess.STDOUT,
                )

                logging.debug("finished stopping IPsec")
            else:
                # When we don't, reload the configuration without the tunnels
                # configured, and shut down all of the tunnels.
                logging.debug("reloading IPsec")

                logging.debug("reloading IPsec secrets")
                subprocess.check_output(
                    [ipsec, "rereadsecrets"],
                    stderr=subprocess.STDOUT,
                )

                logging.debug("reloading IPsec configuration")
                subprocess.check_output(
                    [ipsec, "reload"],
                    stderr=subprocess.STDOUT,
                )

                for local, remote in self.mesh_tunnel_links:
                    logging.debug("shutting down IPsec tunnel %s-%s" % (str(local), str(remote)))
                    subprocess.check_output(
                        [ipsec, "down", "%s-%s" % (str(local), str(remote))],
                        stderr=subprocess.STDOUT,
                    )

                logging.debug("finished reloading IPsec")
        except subprocess.CalledProcessError as e:
            logging.error("error detected in process call:\n%s" % e.output.decode('UTF-8'))
            raise

        logging.debug("finished stopping IPsec daemon management")


    def shutdown(self):
        """
        Permanently shut down this OverlayDaemon.
        Only use if the program is exiting.
        """

        if self.shut_down == True:
            return

        self.shut_down = True

        logging.info("Shutting down daemon...")

        self.stop()
        daemon.ipdb.release()

        logging.info("Shut down.")


    def ipsec_config_add(self, key, value):
        """
        Add a variable to render to the IPsec configuration template.
        """

        logging.debug("adding variable %s to IPsec configuration" % key)
        self.ipsec_config[key] = value


class Overlay(object):
    """
    Create and manage an overlay.
    """


    #
    ## Constructor.
    #


    def __init__(self, daemon, configuration_path):
        # Relevant global fields.
        self.overlays = daemon.overlays

        self.lib_dir = daemon.lib_dir
        self.fwbuilder_script_dir = daemon.fwbuilder_script_dir

        self.logging_level = daemon.logging_level

        # Load the overlay configuration file.
        self.config = configparser.ConfigParser()
        self.config.read(configuration_path)

        # ipdb configuration. The network namespace ipdb gets loaded later.
        self.ipdb = None
        self.root_ipdb = daemon.ipdb

        # Check whether this overlay is enabled or not.
        if 'enabled' in self.config['overlay']:
            self.enabled = Util.boolean_get(self.config['overlay']['enabled'])
        else:
            self.enabled = True

        # Generate the list of nodes, sorted numerically.
        nodes_dict = {}

        for key in self.config['overlay'].keys():
            if key.startswith('node-'):
                nodes_dict[int(re.sub('^node-', '', key))] = tuple(self.config['overlay'][key].split())

        self.nodes = [nodes_dict[key] for key in sorted(nodes_dict.keys())]

        # Get the node dictionary for this node from the list of nodes.
        self.this_node = next((node for node in self.nodes if node[0] == Util.name_get(self.config['overlay']['this-node'])), None)

        # The name of the overlay. Also the name of the network namespace.
        self.name = Util.name_get(self.config['overlay']['name'])
        self.netns_name = self.name

        # Used to configure the overlay's BGP routing system AS number. 
        self.asn = int(self.config['overlay']['asn'])

        # Used for determining the available /31 subnets for the mesh tunnels.
        self.linknet_pool = Util.ip_network_get(self.config['overlay']['linknet-pool'])

        # Get the (absolute or relative) path to the fwbuilder script to
        # configure the firewall in this overlay.
        self.fwbuilder_script = self.config['overlay']['fwbuilder-script'] if 'fwbuilder-script' in self.config['overlay'] else None

        # Used to generate the configuration for the BIRD routing daemon.
        self.bird_config = {}
        self.bird6_config = {}
        self.bird_config_template = daemon.bird_config_template

        # Used by Overlay.interface_name().
        self.interface_names = daemon.interface_names

        # Used by Overlay.gre_key().
        self.mesh_tunnel_links = daemon.mesh_tunnel_links

        # Network namespace root directory. Used for saving network namespace
        # specific configuration files.
        self.netns_root = os.path.join(self.lib_dir, "netns", self.netns_name)

        # Sanity checks.
        if self.this_node is None:
            raise Exception("'%s' is missing from node list" % self.config['overlay']['this-node'])

        if len(self.nodes) != len(set(self.nodes)):
            raise Exception("node list contains a duplicate")

        # Initial operating state of the overlay.
        self.stopped = False

        # Start the overlay.
        self.start()


    #
    ## Overlay-wide and overlay daemon-wide helper methods..
    #


    def links(self):
        """
        Bi-directionally enumerate all of the links in a mesh, with each link's reverse immediately following it.
        """

        # The added nodes list stores the list of nodes with their links
        # already made in the list. Iterations of the list of nodes will 
        # make links to every node on on this added nodes list before
        # adding themselves to it for the next iteration.
        #
        # Creating links this way allows new nodes to be added without
        # affecting what the links() method previously generated. In other
        # words, when new hosts get added, their links get *appended* to the
        # end of the links list.

        links = []
        added_nodes = []

        for peer_node in self.nodes:
            peer_node_name = peer_node[0]
            peer_node_address = peer_node[1]

            for node_name, node_address in added_nodes:
                link = (node_name, peer_node_name)
                if node_name is not peer_node_name and link not in links and link[::-1] not in links:
                    links.append(link)
                    links.append(link[::-1])

            added_nodes.append(peer_node)

        return links


    def overlay_get(self, name):
        """
        Gets the Overlay object for the named overlay.
        """

        for overlay in self.overlays:
            if name == overlay.netns_name:
                return overlay

        raise ValueError("unable to find overlay with name %s" % name)


    def interface_name(self, name, suffix=None, limit=15):
        """
        Creates a valid, unique (in this overlay daemon) interface name based
        on the given base name string, and returns it.
        """

        ifname_num = 0

        while True:
            digits = len(str(ifname_num))

            if suffix is not None:
                ifname_base = "%s%s" % (re.sub('[^A-Za-z0-9]', '', name)[:limit - len(suffix) - digits], suffix)
            else:
                ifname_base = re.sub('[^A-Za-z0-9]', '', name)[:limit - digits]

            ifname = "%s%i" % (ifname_base, ifname_num)

            if ifname not in self.interface_names:
                break

            ifname_num += 1

        self.interface_names.append(ifname)
        return ifname


    def gre_key(self, local, remote):
        """
        Generate a unique key value for the given (local, remote) address pair.
        """

        key = 0
        link = (local, remote)

        for l in self.mesh_tunnel_links:
            if l == link:
                key += 1

        return key


    @staticmethod
    def _bird_config_add(dictionary, key, value):
        """
        Add a key-value pair to a dictonary. If the key already exists in the
        dictionary, add the value to the key as an additional value, making the
        actual value an array of entries.
        """

        if key in dictionary:
            if not isinstance(dictionary[key], list):
                dictionary[key] = [dictionary[key]]

            if isinstance(value, list):
                dictionary[key].extend(value)
            else:
                dictionary[key].append(value)
        else:
            dictionary[key] = value


    def bird_config_add(self, key, value):
        """
        Add a variable to render to the BIRD configuration template. If the
        key already exists in the template, add the value to the key as an
        additional value, making the actual value an array of entries.
        """

        logging.debug("adding variable %s to BIRD configuration" % key)
        Overlay._bird_config_add(self.bird_config, key, value)


    def bird6_config_add(self, key, value):
        """
        Add a variable to render to the BIRD6 configuration template. If the
        key already exists in the template, add the value to the key as an
        additional value, making the actual value an array of entries.
        """

        logging.debug("adding variable %s to BIRD6 configuration" % key)
        Overlay._bird_config_add(self.bird6_config, key, value)


    #
    ## Overlay starting methods.
    #


    def start(self):
        """
        Start the overlay.
        """

        if self.enabled == False:
            return

        if self.stopped == True:
            raise Exception("cannot restart an Overlay after it has been stopped, recreate the Overlay object instead")

        self.start_namespace()
        self.start_mesh_tunnels()
        self.start_static_dummies()
        self.start_static_tunnels()
        self.start_static_tuntaps()
        self.start_static_vlans()
        self.start_static_veths()
        self.start_static_overlay_links()
        self.start_static_bgps()
        self.start_bird()
        self.start_firewall()


    def start_namespace(self):
        """
        Create the network namespace.
        """

        # Create the NetNS and IPDB objects for the network namespace.
        self.netns, self.ipdb = Network.netns_create(self.netns_name)

        # Start the loopback interface in the network namespace.
        Network.interface_up(Network.interface_get('lo', self.ipdb))

        # Create the network namespace root directory.
        Util.directory_create(self.netns_root)


    def start_mesh_tunnels(self):
        """
        Create the mesh tunnels which connect the network namespaces on the
        nodes.
        """

        # The netns veth interfaces address one each of a mesh tunnel.
        # Each mesh tunnel is assigned a /31 subnet to address each end of the
        # tunnel.
        #
        # The range of addresses these /31 subnets are assigned from is defined
        # by the linknet_pool overlay configuration variable.
        linknet_pool_address_base = self.linknet_pool.network_address
        linknet_pool_address_end = self.linknet_pool.broadcast_address

        for index, link in enumerate(self.links()):
            # Check if this link requires a tunnel on this host. If not,
            # continue.
            if link[0] != self.this_node[0]:
                continue

            # Set some required data so the tunnel knows which direction it
            # needs to configure itself in.

            # Pair number. Increases for a change in nodes which are being
            # linked, rather than direction.
            pair_num = math.floor(index / 2)

            # Interface names.
            gretap_name = "m%il%i" % (self.asn, pair_num)
            ipsec_name = "%sip" % gretap_name
            bridge_name = "%sbr" % gretap_name
            root_veth_name = "%sv0" % gretap_name
            netns_veth_name = "%sv1" % gretap_name

            # IP addresses used for transit of the mesh tunnels.
            physical_local = None
            physical_remote = None

            for node, address in self.nodes:
                if node == link[0]:
                    physical_local = Util.ip_address_get(address)
                elif node == link[1]:
                    physical_remote = Util.ip_address_get(address)

                if physical_local is not None and physical_remote is not None:
                    break

            # Interface addresses for the mesh tunnel.
            netns_veth_address_local = linknet_pool_address_base + index
            netns_veth_address_remote = Util.ip_address_remote(netns_veth_address_local)
            netns_veth_address_netmask = 127 if Util.ip_network_is_v6(self.linknet_pool) else 31

            # Make sure the number of assigned subnets does not overflow
            # the linknet pool.
            if netns_veth_address_local > linknet_pool_address_end or netns_veth_address_remote > linknet_pool_address_end:
                raise Exception("overflowed linknet pool %s with link %s" % (str(self.linknet_pool), str(link)))

            logging.debug("creating mesh tunnel %s" % gretap_name)

            # Create the mesh tunnel interface.
            gretap_if = Network.gre_create(
                name=gretap_name,
                kind='gretap',
                local=physical_local,
                remote=physical_remote,
                key=self.gre_key(physical_local, physical_remote),
                ipdb=self.root_ipdb,
            )

            # Create the tunnel's veth pair in the root namespace.
            root_veth_if = Network.veth_create(
                name=root_veth_name,
                peer=netns_veth_name,
                ipdb=self.root_ipdb,
            )

            # Create a bridge interface.
            bridge_if = Network.bridge_create(
                name=bridge_name,
                ipdb=self.root_ipdb,
            )

            # Add the root namespace veth interface and the mesh tunnel
            # interface to the bridge, linking them.
            Network.bridge_add_port(
                bridge=bridge_if,
                interface=gretap_if,
            )

            Network.bridge_add_port(
                bridge=bridge_if,
                interface=root_veth_if,
            )

            # Move one of the veth interfaces into the network namespace.
            netns_veth_if = Network.netns_set(
                name=netns_veth_name,
                ipdb=self.root_ipdb,
                netns_name=self.netns_name,
                netns_ipdb=self.ipdb,
            )

            # Add an address to the network namespace veth interface, so it can
            # be addressed from either side of the mesh tunnel.
            Network.interface_add_ip(
                interface=netns_veth_if,
                address=netns_veth_address_local,
                netmask=netns_veth_address_netmask,
            )

            # Bring up all interfaces.
            Network.interface_up(gretap_if)
            Network.interface_up(root_veth_if)
            Network.interface_up(bridge_if)
            Network.interface_up(netns_veth_if)

            # Add the mesh tunnel to the list of routed interfaces.
            logging.debug("adding BGP route for mesh tunnel %s" % gretap_name)

            mesh_tunnel = {
                'interface': gretap_name,

                'local': {
                    'name': link[0],
                    'address': netns_veth_address_local,
                },

                'remote': {
                    'name': link[1],
                    'address': netns_veth_address_remote,
                },
            }

            if Util.ip_network_is_v6(self.linknet_pool):
                self.bird6_config_add('mesh_tunnels', [mesh_tunnel])
            else:
                self.bird_config_add('mesh_tunnels', [mesh_tunnel])

            # Add the local-remote link to the list of mesh tunnel links made.
            self.mesh_tunnel_links.append((physical_local, physical_remote))

            logging.debug("finished creating mesh tunnel %s" % gretap_name)


    def start_static_dummies(self):
        """
        Create static dummy interfaces in the network namespace.
        """

        # The list of static dummy interfaces configured.
        self.static_dummies = []

        for section in self.config.sections():
            if section.startswith('static-dummy'):
                name = Util.section_name_get('static-dummy', section)
                address = Util.ip_address_get(self.config[section]['address'])
                netmask = Util.netmask_get(self.config[section]['netmask'], Util.ip_address_is_v6(address))

                dummy_name = self.interface_name(name)

                logging.debug("creating static dummy %s" % name)

                dummy_if = Network.dummy_create(
                    name=dummy_name,
                    ipdb=self.ipdb,
                )

                Network.interface_add_ip(
                    interface=dummy_if,
                    address=address,
                    netmask=netmask,
                )

                Network.interface_up(tunnel_if)

                # Add the tunnel to the list of routed interfaces.
                static_dummy = {
                    'name': name,
                    'interface': dummy_name,
                }

                logging.debug("adding %s to list of static dummies" % name)
                self.static_dummies.append(static_tunnel)

                logging.debug("adding BGP route for static dummy %s" % name)
                if Util.ip_address_is_v6(address):
                    self.bird6_config_add('dummies', [static_dummy])
                else:
                    self.bird_config_add('dummies', [static_dummy])

                logging.debug("finished creating static dummy %s" % name)


    def start_static_tunnels(self):
        """
        Create a static GRE or gretap tunnel in the network namespace.
        """

        # The list of static tunnels configured.
        self.static_tunnels = []

        for section in self.config.sections():
            if section.startswith('static-tunnel'):
                name = Util.section_name_get('static-tunnel', section)
                mode = Util.enum_get(self.config[section]['mode'], ['gre', 'gretap'])
                local = Util.ip_address_get(self.config[section]['local'])
                remote = Util.ip_address_get(self.config[section]['remote'])
                address = Util.ip_address_get(self.config[section]['address'])
                netmask = Util.netmask_get(self.config[section]['netmask'], Util.ip_address_is_v6(address))

                tunnel_name = self.interface_name(name)

                logging.debug("creating static tunnel %s" % name)

                tunnel_if = Network.gre_create(
                    name=tunnel_name,
                    kind=mode,
                    local=local,
                    remote=remote,
                    key=self.gre_key(local, remote),
                    ipdb=self.ipdb,
                )

                Network.interface_add_ip(
                    interface=tunnel_if,
                    address=address,
                    netmask=netmask,
                )

                Network.interface_up(tunnel_if)

                # Add the tunnel to the list of routed interfaces.
                static_tunnel = {
                    'name': name,
                    'interface': tunnel_name,
                }

                logging.debug("adding %s to list of static tunnels" % name)
                self.static_tunnels.append(static_tunnel)

                logging.debug("adding BGP route for static tunnel %s" % name)
                if Util.ip_address_is_v6(address):
                    self.bird6_config_add('tunnels', [static_tunnel])
                else:
                    self.bird_config_add('tunnels', [static_tunnel])

                logging.debug("finished creating static tunnel %s" % name)


    def start_static_tuntaps(self):
        """
        Create a static TUN or TAP interface in the network namespace.
        """

        # The list of static tunnels configured.
        self.static_tuntaps = []

        for section in self.config.sections():
            if section.startswith('static-tuntap'):
                name = Util.section_name_get('static-tuntap', section)
                mode = Util.enum_get(self.config[section]['mode'], ['tun', 'tap'])
                uid = Util.integer_get(self.config[section]['uid'])
                gid = Util.integer_get(self.config[section]['gid'])
                address = Util.ip_address_get(self.config[section]['address'])
                netmask = Util.netmask_get(self.config[section]['netmask'], Util.ip_address_is_v6(address))

                tuntap_name = self.interface_name(name)

                logging.debug("creating static %s %s" % (mode, name))

                tuntap_if = Network.tuntap_create(
                    name=tuntap_name,
                    mode=mode,
                    uid=uid,
                    gid=gid,
                    ipdb=self.ipdb,
                )

                Network.interface_add_ip(
                    interface=tuntap_if,
                    address=address,
                    netmask=netmask,
                )

                Network.interface_up(tuntap_if)

                # Add the tunnel to the list of routed interfaces.
                static_tuntap = {
                    'name': name,
                    'interface': tunnel_name,
                    'mode': mode,
                }

                logging.debug("adding %s to list of static tuntaps" % name)
                self.static_tunnels.append(static_tunnel)

                logging.debug("adding BGP route for static %s %s" % (mode, name))
                if Util.ip_address_is_v6(address):
                    self.bird6_config_add('tuntaps', [static_tuntap])
                else:
                    self.bird_config_add('tuntaps', [static_tuntap])

                logging.debug("finished creating static %s %s" % (mode, name))


    def start_static_vlans(self):
        """
        Create a static VLAN between a physical interface on the node and the
        network namespace.
        """

        # The list of static VLANs configured.
        self.static_vlans = []

        for section in self.config.sections():
            if section.startswith('static-vlan'):
                name = Util.section_name_get('static-vlan', section)
                id = int(self.config[section]['id'])
                physical_interface = Util.name_get(self.config[section]['physical-interface'])
                address = Util.ip_address_get(self.config[section]['address'])
                netmask = Util.netmask_get(self.config[section]['netmask'], Util.ip_address_is_v6(address))

                vlan_name = self.interface_name(name=name, suffix='vl', limit=13)
                root_veth_name = "%sv0" % vlan_name
                netns_veth_name = "%sv1" % vlan_name
                bridge_name = "%sbr" % vlan_name

                logging.debug("creating static VLAN %s" % name)

                # Find the physical interface in the IPDB.
                physical_if = Network.interface_get(
                    physical_interface,
                    ipdb=self.root_ipdb,
                )

                # Create the VLAN interface.
                vlan_if = Network.vlan_create(
                    name=vlan_name,
                    link=self.root_ipdb.interfaces[physical_interface],
                    id=id,
                    ipdb=self.root_ipdb,
                )

                # Create the veth pair.
                root_veth_if = Network.veth_create(
                    name=root_veth_name,
                    peer=netns_veth_name,
                    ipdb=self.root_ipdb,
                )

                # Move the netns veth interface to the network namespace.
                netns_veth_if = Network.netns_set(
                    name=netns_veth_name,
                    ipdb=self.root_ipdb,
                    netns_name=self.netns_name,
                    netns_ipdb=self.ipdb,
                )

                # Add the assigned address for the VLAN to the netns veth
                # interface.
                Network.interface_add_ip(
                    interface=netns_veth_if,
                    address=address,
                    netmask=netmask,
                )

                # Create a bridge for the physical interface to connect to the
                # network namespace via the veth pair.
                bridge_if = Network.bridge_create(
                    name=bridge_name,
                    ipdb=self.root_ipdb,
                )

                # Add the physical interface and the root veth interface to the
                # bridge.
                Network.bridge_add_port(
                    bridge=bridge_if,
                    interface=vlan_if,
                )

                Network.bridge_add_port(
                    bridge=bridge_if,
                    interface=root_veth_if,
                )

                # Finally, we're done! Bring up the interfaces!
                Network.interface_up(physical_if)
                Network.interface_up(vlan_if)
                Network.interface_up(root_veth_if)
                Network.interface_up(netns_veth_if)
                Network.interface_up(bridge_if)

                # Add the veth interface connected to the VLAN to the list of 
                # routed interfaces.
                static_vlan = {
                    'name': name,
                    'interface': netns_veth_name,
                    'vlan_interface': vlan_name,
                    'root_interface': root_veth_name,
                    'bridge_interface': bridge_name,
                }

                logging.debug("adding %s to list of static VLANs" % name)
                self.static_vlans.append(static_vlan)

                logging.debug("adding BGP route for static VLAN %s" % name)
                if Util.ip_address_is_v6(address):
                    self.bird6_config_add('vlans', [static_vlan])
                else:
                    self.bird_config_add('vlans', [static_vlan])

                logging.debug("finished creating static VLAN %s" % name)


    def start_static_veths(self):
        """
        Create a static veth pair between the network namespace and the root
        namespace.
        """

        # The list of static veths configured.
        self.static_veths = []

        for section in self.config.sections():
            if section.startswith('static-veth'):
                name = Util.section_name_get('static-veth', section)
                inner_address = Util.ip_address_get(self.config[section]['inner-address']) if 'inner-address' in self.config[section] else None
                outer_address = Util.ip_address_get(self.config[section]['outer-address']) if 'outer-address' in self.config[section] else None
                inner_interface_bridged = Util.boolean_get(self.config[section]['inner-interface-bridged']) if 'inner-interface-bridged' in self.config[section] else False
                outer_namespace = Util.name_get(self.config[section]['outer-namespace']) if 'outer-namespace' in self.config[section] else None

                # A valid veth pair only has an address assigned at only one
                # end of the pair. Enforce this restriction.
                if not inner_interface_bridged:
                    if inner_address and outer_address:
                        raise ValueError("set inner-interface-bridged to use both inner-address and outer-address in static veth %s" % name)

                if inner_address:
                    use_ipv6 = Util.ip_address_is_v6(inner_address)
                elif outer_address:
                    use_ipv6 = Util.ip_address_is_v6(outer_address)

                netmask = Util.netmask_get(self.config[section]['netmask'], use_ipv6)

                # Check that inner-address and outer-address are the same type
                # of address.
                if inner_address and outer_address:
                    if type(inner_address) != type(outer_address):
                        raise ValueError("inner-address (%s, %s) and outer-address (%s, %s) must be the same type of IP address" % (str(inner_address), str(type(inner_address)), str(outer_address), str(type(outer_address))))

                dummy_name = self.interface_name(name, limit=12)
                bridge_name = self.interface_name(dummy_name, suffix='br')
                outer_name = self.interface_name(dummy_name, suffix='v')
                inner_name = self.interface_name(dummy_name, suffix='v')

                logging.debug("creating static veth %s" % name)

                # Get the NetNS and IPDB objects for the outer interface's
                # configured network namespace.
                outer_overlay = None
                outer_netns = None
                outer_ipdb = None

                if outer_namespace:
                    # Check if the outer namespace name is the name of an
                    # overlay. If it is, fetch the overlay object, as well
                    # as its NetNS and IPDB objects.
                    try:
                        outer_overlay = self.overlay_get(outer_namespace)
                        outer_netns = outer_overlay.netns
                        outer_ipdb = outer_overlay.ipdb
                    # Couldn't find the outer namespace name in the list of
                    # overlays. Look for it as an external network namespace.
                    except ValueError:
                        outer_netns, outer_ipdb = Network.netns_get(outer_namespace)
                # outer-namespace not defined. Set outer_ipdb to the root
                # namespace IPDB.
                else:
                    outer_ipdb = self.root_ipdb

                # Create the inner and outer interfaces.
                outer_if = Network.veth_create(
                    name=outer_name,
                    peer=inner_name,
                    ipdb=outer_ipdb,
                )

                inner_if = Network.netns_set(
                    name=inner_name,
                    ipdb=outer_ipdb,
                    netns_name=self.netns_name,
                    netns_ipdb=self.ipdb,
                )

                # If the overlay's veth interface is to be bonded to a dummy
                # bridge, do so, and make sure inner-address gets assigned to
                # the bridge instead.
                if inner_interface_bridged:
                    dummy_if = Network.dummy_create(dummy_name, self.ipdb)
                    bridge_if = Network.bridge_create(bridge_name, self.ipdb)

                    Network.bridge_add_port(bridge_if, dummy_if)
                    Network.bridge_add_port(bridge_if, inner_if)

                    inner_address_name = bridge_name
                    inner_address_if = bridge_if
                else:
                    inner_address_name = inner_name
                    inner_address_if = inner_if

                # Determine which interface to assign the address to.
                interface = inner_if if inner_address is not None else outer_if

                # Assign IP addresses to the interfaces, if configured.
                if inner_address:
                    Network.interface_add_ip(
                        interface=inner_address_if,
                        address=inner_address,
                        netmask=netmask,
                    )

                if outer_address:
                    Network.interface_add_ip(
                        interface=outer_if,
                        address=outer_address,
                        netmask=netmask,
                    )

                # Bring up all interfaces.
                Network.interface_up(outer_if)
                Network.interface_up(inner_if)

                if inner_interface_bridged:
                    Network.interface_up(dummy_if)
                    Network.interface_up(bridge_if)

                # We are done with the outer interface's network namespace.
                # Close the NetNS and IPDB objects for it if it is not an
                # overlay.
                if outer_namespace and not outer_overlay:
                    Network.netns_close(outer_namespace, outer_netns, outer_ipdb)

                # Add the interfaces to the list of routed interfaces.
                static_veth = {
                    'name': name,
                    'inner_interface': inner_name,
                    'outer_interface': outer_name,
                    'inner_address_interface': inner_address_name,
                }

                if inner_interface_bridged:
                    static_veth['dummy_interface'] = dummy_name
                    static_veth['bridge_interface'] = bridge_name

                if outer_namespace:
                    static_veth['outer_namespace'] = outer_namespace

                logging.debug("adding %s to list of static veths" % name)
                self.static_veths.append(static_veth)

                logging.debug("adding BGP route for static veth %s" % name)
                if use_ipv6:
                    self.bird6_config_add('veths', [static_veth])
                else:
                    self.bird_config_add('veths', [static_veth])

                logging.debug("finished creating static veth %s" % name)


    def start_static_overlay_links(self):
        """
        Link and distribute routes between two configured overlays.
        """

        # The list of static veths configured.
        self.static_overlay_links = []

        for section in self.config.sections():
            if section.startswith('static-overlay-link'):
                name = Util.section_name_get('static-overlay-link', section)
                inner_overlay_name = Util.name_get(self.config[section]['inner-overlay-name'])
                inner_address = Util.ip_address_get(self.config[section]['inner-address'])
                outer_address = Util.ip_address_get(self.config[section]['outer-address'])
                netmask = Util.netmask_get(self.config[section]['netmask'])

                if (type(inner_address) != type(outer_address)):
                    raise ValueError("inner address %s (%s) and outer address %s (%s) must be the same type of IP address" % (inner_address, str(type(inner_address)), outer_address, str(type(outer_address))))

                dummy_name = self.interface_name(name, limit=13)
                bridge_name = self.interface_name(dummy_name, suffix='br')
                outer_name = self.interface_name(dummy_name, suffix='v')
                inner_name = self.interface_name(dummy_name, suffix='v')

                logging.debug("creating link %s between overlays %s and %s" % (name, self.name, inner_overlay_name))

                # Get the NetNS and IPDB objects for the outer interface's
                # configured network namespace.
                outer_overlay = self.overlay_get(inner_overlay_name)

                # Create the inner and outer veth interfaces, which link the
                # overlays together.
                outer_if = Network.veth_create(
                    name=outer_name,
                    peer=inner_name,
                    ipdb=self.ipdb,
                )

                inner_if = Network.netns_set(
                    name=inner_name,
                    ipdb=self.ipdb,
                    netns_name=outer_overlay.netns_name,
                    netns_ipdb=outer_overlay.ipdb,
                )

                # Create a dummy interface for the outer veth interface to be
                # bridged with.
                dummy_if = Network.dummy_create(
                    name=dummy_name,
                    ipdb=self.ipdb,
                )

                bridge_if = Network.bridge_create(
                    name=bridge_name,
                    ipdb=self.ipdb,
                )

                Network.bridge_add_port(
                    bridge=bridge_if,
                    interface=outer_if,
                )

                Network.bridge_add_port(
                    bridge=bridge_if,
                    interface=dummy_if,
                )

                # Assign address to the interfaces.
                Network.interface_add_ip(
                    interface=bridge_if,
                    address=outer_address,
                    netmask=netmask,
                )

                Network.interface_add_ip(
                    interface=inner_if,
                    address=inner_address,
                    netmask=netmask,
                )

                # Bring up both the inner and outer interfaces, and their
                # linking interfaces.
                Network.interface_up(outer_if)
                Network.interface_up(inner_if)

                Network.interface_up(dummy_if)
                Network.interface_up(bridge_if)

                # Add the inner interface to the list of routed interfaces.
                static_overlay_link = {
                    'name': name,
                    'inner': {
                        'overlay': inner_overlay_name,
                        'asn': outer_overlay.asn,
                        'interface': inner_name,
                        'address': inner_address,
                    },
                    'outer': {
                        'overlay': self.name,
                        'asn': self.asn,
                        'interface': outer_name,
                        'dummy': {
                            'interface': dummy_name,
                        },
                        'bridge': {
                            'interface': bridge_name,
                            'address': outer_address,
                        },
                    },
                }

                logging.debug("adding %s to list of static overlay links" % name)
                self.static_overlay_links.append(static_overlay_link)

                logging.debug("adding BGP route for static overlay link %s" % name)
                if Util.ip_address_is_v6(inner_address):
                    self.bird6_config_add('overlay_links', [static_overlay_links])
                    outer_overlay.bird6_config_add('overlay_links', [static_overlay_link])
                else:
                    self.bird_config_add('overlay_links', [static_overlay_link])
                    outer_overlay.bird_config_add('overlay_links', [static_overlay_link])

                logging.debug("finished creating link %s between overlays %s and %s" % (name, self.name, inner_overlay_name))


    def start_static_bgps(self):
        """
        Create a static BGP protocol in the network namespace.
        """

        for section in self.config.sections():
            if section.startswith('static-bgp'):
                bgp = {}

                name = Util.section_name_get('static-bgp', section)
                neighbor = Util.ip_address_get(self.config[section]['neighbor'])
                local = Util.ip_address_get(self.config[section]['local']) if 'local' in self.config[section] else None

                local_asn = int(self.config[section]['local-asn']) if 'local-asn' in self.config[section] else self.asn
                neighbor_asn = int(self.config[section]['neighbor-asn']) if 'neighbor-asn' in self.config[section] else self.asn

                bfd = Util.boolean_get(self.config[section]['bfd']) if 'bfd' in self.config[section] else False
                ttl_security = Util.boolean_get(self.config[section]['ttl-security']) if 'ttl-security' in self.config[section] else False

                description = self.config[section]['description'] if 'description' in self.config[section] else None

                bgp['name'] = name

                bgp['neighbor'] = str(neighbor)
                if local is not None:
                    bgp['local'] = str(local)

                bgp['local_asn'] = local_asn
                bgp['neighbor_asn'] = neighbor_asn

                bgp['bfd'] = 'on' if bfd else 'off'
                bgp['ttl_security'] = 'on' if ttl_security else 'off'

                if description is not None:
                    bgp['description'] = description

                # The import prefixes is a list of IP address subnets to filter
                # the BGP protocol's import function against.
                import_prefixes = []
                for key in self.config[section].keys():
                    if key.startswith('import-prefix'):
                        import_prefixes.append(self.config[section][key])

                if len(import_prefixes) > 0:
                    bgp['import_prefixes'] = [Util.bird_prefix_get(prefix) for prefix in import_prefixes]

                # Add the static BGP to either the BIRD or BIRD6 configuration,
                # depending on whether IPv6 is used at all or not.
                logging.debug("adding static BGP %s to BIRD configuration" % name)

                if Util.ip_address_is_v6(neighbor) or (local is not None and Util.ip_address_is_v6(local)):
                    self.bird6_config_add('bgps', value=[bgp])
                else:
                    self.bird_config_add('bgps', value=[bgp])

                logging.debug("finished adding static BGP %s to BIRD configuration" % name)


    def start_bird_daemon(self, bird, bird_config_file, bird_socket_file, bird_pid_file):
        # If there is a BIRD daemon already running, connect to its socket and
        # tell it to reload its configuration.
        if Util.pid_exists(pid_file=bird_pid_file):
            try:
                logging.debug("reloading BIRD")

                logging.debug("connecting to the BIRD control socket")

                sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                sock.connect(bird_socket_file)

                datagram = sock.recv(1024)
                response = datagram.decode('UTF-8')

                if not re.match("0001 BIRD [0-9.]* ready.\n", response):
                    raise Exception("unable to connect to BIRD. output:\n%s" % response)

                logging.debug("reloading BIRD configuration")

                sock.send(bytes("configure \"%s\"\n" % bird_config_file, 'UTF-8'))

                datagram = sock.recv(1024)
                response = datagram.decode('UTF-8')

                if "0002-Reading configuration from %s" % bird_config_file not in response or ("0003 Reconfigured" not in response and "0004 Reconfiguration in progress" not in response):
                    raise Exception("unable to reload BIRD configuration. output:\n%s" % response)

                sock.close()
                logging.debug("finished reloading BIRD")
                return
            except socket.error as e:
                if e.errno != errno.ECONNREFUSED:
                    raise

        # If not, then start a new BIRD daemon. 
        try:
            ip = find_executable("ip")

            if ip is None:
                raise Exception("cannot find ip (iproute2) executable path")

            logging.debug("starting BIRD")

            subprocess.check_output([
                ip, "netns", "exec", self.netns_name,
                bird,
                    "-c", bird_config_file,
                    "-s", bird_socket_file,
                    "-P", bird_pid_file,
            ], stderr=subprocess.STDOUT)

            logging.debug("finished starting BIRD")
        except subprocess.CalledProcessError as e:
            logging.error("error detected in process call:\n%s" % e.output.decode('UTF-8'))
            raise


    def start_bird(self):
        """
        Configure and start the BIRD routing daemon.
        """

        logging.debug("starting the BIRD routing daemon")

        # BIRD file paths.
        bird_config_dir = os.path.join(self.netns_root, "etc", "bird")
        bird_config_file = os.path.join(bird_config_dir, "bird.conf")

        bird_socket_dir = os.path.join(self.netns_root, "run", "bird")
        bird_socket_file = os.path.join(bird_socket_dir, "bird.ctl")
        bird_pid_file = os.path.join(bird_socket_dir, "bird.pid")

        bird_log_dir = os.path.join(self.netns_root, "var", "log", "bird")
        bird_log_file = os.path.join(bird_log_dir, "bird.log")

        bird6_config_dir = os.path.join(self.netns_root, "etc", "bird")
        bird6_config_file = os.path.join(bird_config_dir, "bird6.conf")

        bird6_socket_dir = os.path.join(self.netns_root, "run", "bird")
        bird6_socket_file = os.path.join(bird_socket_dir, "bird6.ctl")
        bird6_pid_file = os.path.join(bird_socket_dir, "bird6.pid")

        bird6_log_dir = os.path.join(self.netns_root, "var", "log", "bird")
        bird6_log_file = os.path.join(bird_log_dir, "bird6.log")

        # Create the required BIRD directories.
        if self.bird_config:
          logging.debug("creating BIRD configuration directory")
          Util.directory_create(bird_config_dir)

          logging.debug("creating BIRD socket directory")
          Util.directory_create(bird_socket_dir)

          logging.debug("creating BIRD log directory")
          Util.directory_create(bird_log_dir)

        if self.bird6_config:
          logging.debug("creating BIRD6 configuration directory")
          Util.directory_create(bird6_config_dir)

          logging.debug("creating BIRD6 socket directory")
          Util.directory_create(bird6_socket_dir)

          logging.debug("creating BIRD6 log directory")
          Util.directory_create(bird6_log_dir)

        # Actual configuration time.
        logging.debug("configuring BIRD")

        # Add required parameters to the BIRD configuration.
        if self.bird_config:
            self.bird_config_add(key='overlay', value=self.name)
            self.bird_config_add(key='file', value=bird_config_file)
            self.bird_config_add(key='netns', value=self.netns_name)
            self.bird_config_add(key='asn', value=self.asn)
            self.bird_config_add(key='logging_level', value=self.logging_level)
            self.bird_config_add(key='log_file', value=bird_log_file)

        if self.bird6_config:
            self.bird6_config_add(key='overlay', value=self.name)
            self.bird6_config_add(key='file', value=bird6_config_file)
            self.bird6_config_add(key='netns', value=self.netns_name)
            self.bird6_config_add(key='asn', value=self.asn)
            self.bird6_config_add(key='logging_level', value=self.logging_level)
            self.bird6_config_add(key='log_file', value=bird6_log_file)

        # Save the BIRD configuration.
        if self.bird_config:
            logging.debug("saving bird configuration to disk")

            with open(bird_config_file, 'w') as f:
                f.write(self.bird_config_template.render(self.bird_config))

        if self.bird6_config:
            logging.debug("saving bird6 configuration to disk")

            with open(bird6_config_file, 'w') as f:
                f.write(self.bird_config_template.render(self.bird6_config))

        logging.debug("finished configuring BIRD")

        # Start the BIRD routing daemon for both IPv4 and IPv6.
        if self.bird_config:
            bird = find_executable("bird")

            if bird is None:
                raise Exception("cannot find bird executable path")

            self.start_bird_daemon(
                bird,
                bird_config_file,
                bird_socket_file,
                bird_pid_file,
            )

        if self.bird6_config:
            bird6 = find_executable("bird6")

            if bird6 is None:
                raise Exception("cannot find bird6 executable path")

            self.start_bird_daemon(
                bird6,
                bird6_config_file,
                bird6_socket_file,
                bird6_pid_file,
            )

        logging.debug("finished starting the BIRD routing daemon")


    def start_firewall(self):
        """
        Run the fwbuilder script in the network namespace.
        """

        if self.fwbuilder_script is not None:
            try:
                ip = find_executable("ip")

                if ip is None:
                    raise Exception("cannot find ip (iproute2) executable path")

                if os.path.isabs(self.fwbuilder_script):
                    command = self.fwbuilder_script
                else:
                    command = os.path.join(self.fwbuilder_script_dir, self.fwbuilder_script)

                logging.debug("building firewall for namespace %s" % self.netns_name)

                subprocess.check_output([
                    ip, "netns", "exec", self.netns_name,
                    command,
                ], stderr=subprocess.STDOUT)

                logging.debug("finished building firewall for namespace %s" % self.netns_name)

            except subprocess.CalledProcessError as e:
                logging.error("error detected in process call:\n%s" % e.output.decode('UTF-8'))
                raise


    #
    ## Overlay stopping methods.
    #


    def stop(self):
        """
        Stop the overlay.
        """

        if self.enabled == False:
            return

        # Ensure this Overlay object cannot be restarted.
        self.stopped = True

        # Already removed because it is entirely contained in the network
        # namespace.
        # self.stop_firewall()
        self.stop_bird()
        # Already removed because it is entirely contained in BIRD.
        # self.stop_static_bgps()
        self.stop_static_overlay_links()
        self.stop_static_veths()
        self.stop_static_vlans()
        self.stop_static_tuntaps()
        self.stop_static_tunnels()
        self.stop_static_dummies()
        self.stop_mesh_tunnels()
        self.stop_namespace()


    def stop_namespace(self):
        """
        Delete the network namespace.
        """

        logging.debug("removing namespace %s" % self.netns_name)

        Network.netns_remove(self.netns_name, self.netns, self.ipdb)

        logging.debug("removing the netns root tree for namespace %s" % self.netns_name)
        shutil.rmtree(self.netns_root)

        logging.debug("removed namespace %s" % self.netns_name)


    def stop_mesh_tunnels(self):
        """
        Destroy the root namespace components of the mesh tunnels.
        """

        logging.debug("removing mesh tunnels")

        Network.interface_remove(
            self.root_ipdb,
            expr="^m%il[0-9][0-9]*br$" % self.asn,
        )

        Network.interface_remove(
            self.root_ipdb,
            expr="^m%il[0-9][0-9]*v0$" % self.asn,
        )

        Network.interface_remove(
            self.root_ipdb,
            expr="^m%il[0-9][0-9]*$" % self.asn,
        )

        logging.debug("finished removing mesh tunnels")


    def stop_static_dummies(self):
        """
        Destroy the static dummies.
        """

        for dummy in self.static_dummies:
            name = dummy['name']
            dummy_name = dummy['interface']

            logging.debug("removing static dummy %s" % name)

            Network.interface_remove(
                self.ipdb,
                name=dummy_name,
            )

            logging.debug("finished removing static dummy %s" % name)


    def stop_static_tunnels(self):
        """
        Destroy the static tunnels.
        """

        for tunnel in self.static_tunnels:
            name = tunnel['name']
            tunnel_name = tunnel['interface']

            logging.debug("removing static tunnel %s" % name)

            Network.interface_remove(
                self.ipdb,
                name=tunnel_name,
            )

            logging.debug("finished removing static tunnel %s" % name)


    def stop_static_tuntaps(self):
        """
        Destroy the static TUN/TAP interfaces.
        """

        for tuntap in self.static_tuntaps:
            name = tunnel['name']
            tuntap_name = tunnel['interface']
            mode = tunnel['mode']

            logging.debug("removing static %s %s" % (mode, name))

            Network.interface_remove(
                self.ipdb,
                name=tuntap_name,
            )

            logging.debug("finished removing static %s %s" % (mode, name))


    def stop_static_vlans(self):
        """
        Destroy the root namespace components of the static VLANs.
        """

        for vlan in self.static_vlans:
            name = vlan['name']

            logging.debug("removing static VLAN %s" % name)

            Network.interface_remove(
                self.root_ipdb,
                name=vlan['bridge_interface'],
            )

            Network.interface_remove(
                self.root_ipdb,
                name=vlan['root_interface'],
            )

            Network.interface_remove(
                self.root_ipdb,
                name=vlan['vlan_interface'],
            )

            logging.debug("finished removing static VLAN %s" % name)


    def stop_static_veths(self):
        """
        Destroy the root namespace components of the static veth pairs.
        """

        for veth in self.static_veths:
            name = veth['name']
            inner_name = veth['inner_interface']
            outer_name = veth['outer_interface']
            dummy_name = veth['dummy_interface'] if 'dummy_interface' in veth else None
            bridge_name = veth['bridge_interface'] if 'bridge_interface' in veth else None
            outer_namespace = veth['outer_namespace'] if 'outer_namespace' in veth else None

            logging.debug("removing static veth %s" % name)

            # Find the outer namespace, or overlay if it is one.
            outer_overlay = None
            outer_netns = None
            outer_ipdb = None

            if outer_namespace:
                try:
                    outer_overlay = self.overlay_get(outer_namespace)
                    outer_netns = outer_overlay.netns
                    outer_ipdb = outer_overlay.ipdb
                except ValueError:
                    outer_netns, outer_ipdb = Network.netns_get(outer_namespace)
            else:
                outer_ipdb = self.root_ipdb

            if bridge_name:
                Network.interface_remove(
                    self.ipdb,
                    name=bridge_name,
                )

            if dummy_name:
                Network.interface_remove(
                    self.ipdb,
                    name=dummy_name,
                )

            # Removes both the outer and inner interfaces.
            Network.interface_remove(
                outer_ipdb,
                name=outer_name,
            )

            # Shutdown the NetNS/IPDB object if they are not connected to an
            # overlay.
            if outer_namespace and not outer_overlay:
                Network.netns_close(outer_namespace, outer_netns, outer_ipdb)

            logging.debug("finished removing static veth %s" % name)


    def stop_static_overlay_links(self):
        """
        Destroy links between overlays.
        """

        for overlay_link in self.static_overlay_links:
            name = overlay_link['name']
            outer_overlay_name = overlay_link['outer']['overlay']
            inner_overlay_name = overlay_link['inner']['overlay']

            outer_name = overlay_link['outer']['interface']
            dummy_name = overlay_link['outer']['dummy']['interface']
            bridge_name = overlay_link['outer']['bridge']['interface']

            logging.debug("removing static link %s between overlays %s and %s" % (name, outer_overlay_name, inner_overlay_name))

            Network.interface_remove(
                self.ipdb,
                name=bridge_name,
            )

            Network.interface_remove(
                self.ipdb,
                name=dummy_name,
            )

            Network.interface_remove(
                self.ipdb,
                name=outer_name,
            )

            logging.debug("finished removing static link %s between overlays %s and %s" % (name, outer_overlay_name, inner_overlay_name))


    def stop_bird(self):
        """
        Stop the BIRD routing daemon. The configuration gets destroyed when
        the network namespace root directory gets cleaned up.
        """

        bird_pid_file = os.path.join(self.netns_root, "run", "bird", "bird.pid")
        bird6_pid_file = os.path.join(self.netns_root, "run", "bird", "bird6.pid")

        logging.debug("stopping the BIRD routing daemon")

        pid = Util.pid_get(pid_file=bird_pid_file)
        pid6 = Util.pid_get(pid_file=bird6_pid_file)

        if pid is not None:
            os.kill(pid, signal.SIGTERM)

        if pid6 is not None:
            os.kill(pid6, signal.SIGTERM)

        logging.debug("stopped the BIRD routing daemon")


class Network(object):
    """
    Network interface manipulation static methods.
    """

    @staticmethod
    def interface_get(name, ipdb):
        """
        Tries to find an interface with the given name in the chosen IPDB
        and returns it. Throws an exception if it can't find it.
        """

        if name in ipdb.by_name.keys():
            return ipdb.interfaces[name]
        else:
            raise Exception("unable to find interface %s in IPDB" % name)


    @staticmethod
    def interface_add_ip(interface, address, netmask):
        """
        Add the given IP address (either a string, IPv4Address or IPv6Address)
        with its netmask to the chosen interface.
        """

        ip_tuple = (str(address), netmask)
        ip_string = "%s/%i" % ip_tuple

        if ip_tuple in interface.ipaddr:
            logging.debug("no need to add address %s to interface %s" % (ip_string, interface.ifname))
            return

        logging.debug("adding address %s to interface %s" % (ip_string, interface.ifname))

        interface.add_ip(ip_string).commit()


    @staticmethod
    def _interface_remove(ipdb, interface, delay=0.001, timeout=1.0):
        """
        Remove an interface, and wait for it to show as removed in the IPDB.
        """

        waited = 0.0
        name = interface.ifname

        logging.debug("removing interface %s" % name)

        interface.down()
        interface.remove().commit()

        # pyroute2 seems to take a little while to actually execute
        # an interface removal. Wait for the IPDB to register that the
        # interface no longer exists.
        # This stops waiting after a while, to prevent infinite loops.
        while name in ipdb.by_name.keys() and waited < timeout:
            time.sleep(delay)
            waited += delay

        if name in ipdb.by_name.keys():
            raise Exception("interface %s still exists in IPDB even after waiting" % name)

        logging.debug("finished removing interface %s" % name)


    @staticmethod
    def interface_remove(ipdb, interface=None, name=None, expr=None):
        """
        Remove an interface, or any interface matching a given regular
        expression.

        The required arguments are the IPDB object the interface belongs to,
        and one of an interface object, an interface name, or a matching
        regular expression.
        """

        if interface is not None:
            Network._interface_remove(ipdb, interface)
        elif name is not None:
            if name in ipdb.by_name.keys():
                Network._interface_remove(ipdb, ipdb.interfaces[name])
        elif expr is not None:
            for name in ipdb.by_name.keys():
                if re.match(expr, name):
                    Network._interface_remove(ipdb, ipdb.interfaces[name])
        else:
            raise Exception("invalid arguments for interface_remove: interface=%s, name=%s, expr=%s, ipdb=" % (interface.ifname if interface is not None else "None", str(name), str(expr), str(ipdb)))


    @staticmethod
    def interface_up(interface):
        """
        Bring up the given interface.
        """

        logging.debug("bringing up interface %s" % interface.ifname)
        interface.up().commit()


    @staticmethod
    def bridge_create(name, ipdb):
        """
        Create a bridge interface with the given name in a chosen IPDB.
        Returns the interface entry from the IPDB.
        """

        if name not in ipdb.by_name.keys():
            logging.debug("creating bridge interface %s" % name)

            interface = ipdb.create(
                ifname=name,
                kind='bridge',
            )

            ipdb.commit()
        else:
            logging.debug("no need to create bridge interface %s" % name)
            interface = ipdb.interfaces[name]

        return interface


    @staticmethod
    def bridge_add_port(bridge, interface):
        """
        Add the given interface to the list of ports for a given bridge.
        """

        if interface.index not in bridge.ports:
            logging.debug("adding interface %s to bridge %s" % (interface.ifname, bridge.ifname))

            bridge.add_port(interface).commit()
        else:
            logging.debug("no need to add interface %s to bridge %s" % (interface.ifname, bridge.ifname))


    @staticmethod
    def dummy_create(name, ipdb):
        """
        Create a dummy interface with the given name in a chosen IPDB.
        Returns the interface entry from the IPDB.
        """

        if name not in ipdb.by_name.keys():
            logging.debug("creating dummy interface %s" % name)

            interface = ipdb.create(
                ifname=name,
                kind='dummy',
            )

            ipdb.commit()
        else:
            logging.debug("no need to create dummy interface %s" % name)
            interface = ipdb.interfaces[name]

        return interface


    @staticmethod
    def gre_create(name, local, remote, ipdb, kind='gre', ttl=16, key=None, ikey=None, okey=None, iflags=32, oflags=32):
        """
        Create a gre/gretap interface with the given name in a chosen IPDB.
        Returns the interface entry from the IPDB.
        """

        if key is not None:
            ikey = key
            okey = key

        if name in ipdb.by_name.keys():
            interface = ipdb.interfaces[name]

            if (interface.kind != kind or
                    # Cast for compatibility with IPv4Address/IPv6Address.
                    interface.gre_local != str(local) or
                    interface.gre_remote != str(remote) or
                    interface.gre_ttl != ttl or
                    interface.gre_ikey != ikey or
                    interface.gre_okey != okey or
                    interface.gre_iflags != iflags or
                    interface.gre_oflags != oflags):
                logging.debug("removing existing interface %s" % name)
                Network.interface_remove(ipdb, interface=interface)
            else:
                logging.debug("no need to create %s tunnel %s" % (kind, name))
                return interface

        logging.debug("creating %s tunnel %s" % (kind, name))

        interface = ipdb.create(
            ifname=name,
            kind=kind,
            # Cast for compatibility with IPv4Address/IPv6Address.
            gre_local=str(local),
            gre_remote=str(remote),
            gre_ttl=ttl,
            gre_ikey=ikey,
            gre_okey=okey,
            gre_iflags=iflags,
            gre_oflags=oflags,
        )

        ipdb.commit()
        return interface


    @staticmethod
    def tuntap_create(name, ipdb, mode='tap', uid=0, gid=0, ifr=None):
        """
        Create a tun/tap interface with the given name in the chosen IPDB.
        Returns the interface entry from the IPDB.
        """

        if name in ipdb.by_name.keys():
            interface = ipdb.interfaces[name]

            if (interface.kind != 'tuntap' or
                    interface.mode != mode or
                    interface.uid != uid or
                    interface.gid != gid or
                    interface.ifr != ifr):
                logging.debug("removing existing interface %s" % name)
                Network.interface_remove(ipdb, interface=interface)
            else:
                logging.debug("no need to create tuntap interface %s" % name)
                return interface
        else:
            logging.debug("creating tuntap interface %s" % name)

        interface = ipdb.create(
            ifname=name,
            kind='tuntap',
            mode=mode,
            uid=uid,
            gid=gid,
            ifr=ifr,
        )

        ipdb.commit()
        return interface


    @staticmethod
    def vlan_create(name, link, id, ipdb):
        """
        Create a IEEE 802.1Q VLAN interface with the given name, physical link
        and ID in the chosen IPDB, and return the interface.
        """

        if name in ipdb.by_name.keys():
            interface = ipdb.interfaces[name]

            if (interface.kind != 'vlan' or
                    ipdb.by_index[interface.link] != link or
                    interface.vlan_id != id):
                logging.debug("removing existing interface %s" % name)
                Network.interface_remove(ipdb, interface=interface)
            else:
                logging.debug("no need to create VLAN interface %s" % name)
                return interface
        else:
            logging.debug("creating VLAN interface %s" % name)

        interface = ipdb.create(
            ifname=name,
            kind='vlan',
            link=link,
            vlan_id=id,
        )

        ipdb.commit()
        return interface


    @staticmethod
    def veth_create(name, peer, ipdb):
        """
        Create a veth pair with the given names in the chosen IPDB, and
        returns the root interface. The peer must be retrieved separately.
        """

        if name in ipdb.by_name.keys():
            interface = ipdb.interfaces[name]

            if interface.kind != 'veth':
                logging.debug("removing existing interface %s" % name)
                Network.interface_remove(ipdb, interface=interface)
            else:
                logging.debug("no need to create veth pair %s and %s" % (name, peer))
                return interface

        logging.debug("creating veth pair %s and %s" % (name, peer))

        interface = ipdb.create(
            ifname=name,
            kind='veth',
            peer=peer,
        )

        ipdb.commit()
        return interface


    @staticmethod
    def netns_get(name):
        """
        Check if a network namespace exists, and return a tuple containing its
        NetNS and IPDB objects. Raise an Exception if it doesn't exist.
        """

        if name not in netns.listnetns():
            raise Exception("no existing network namespace with name %s" % name)

        logging.debug("creating the NetNS for network namespace %s" % name)
        nl = NetNS(name)

        logging.debug("creating the IPDB for network namespace %s" % name)
        ipdb = IPDB(nl=nl)

        return (nl, ipdb)


    @staticmethod
    def netns_create(name):
        """
        Create a network namespace, and return a tuple containing its
        NetNS and IPDB objects.
        """

        try:
            netns.create(name)
        except FileExistsError:
            logging.debug("no need to create network namespace %s" % name)
        except:
            raise Exception("could not create network namespace %s" % name)
        else:
            logging.debug("creating network namespace %s" % name)

        return Network.netns_get(name)


    @staticmethod
    def netns_set(name, ipdb, netns_name, netns_ipdb):
        """
        Moves an interface into a chosen network namespace. Returns the
        interface object from the network namespace.
        """

        if name not in netns_ipdb.by_name.keys():
            logging.debug("moving interface %s to network namespace %s" % (name, netns_name))

            ipdb.interfaces[name].net_ns_fd = netns_name
            ipdb.commit()
        else:
            logging.debug("no need to move interface %s to network namespace %s" % (name, netns_name))

        return netns_ipdb.interfaces[name]


    @staticmethod
    def netns_close(name, nl, ipdb):
        """
        Close a network namespace's IPDB and NetNS objects.
        """

        logging.debug("releasing the IPDB for network namespace %s" % name)
        ipdb.release()

        logging.debug("closing the NetNS for network namespace %s" % name)
        nl.close()


    @staticmethod
    def netns_remove(name, nl, ipdb):
        """
        Close a network namespace's IPDB and NetNS objects, and remove it from
        the system.
        """

        Network.netns_close(name, nl, ipdb)

        logging.debug("removing the network namespace %s from system" % name)
        netns.remove(name)


class Util(object):
    """
    Argument/parameter processing.
    """

    @staticmethod
    def integer_get(value):
        """
        Get an integer value from a string. Raise a ValueError if the string
        is not a valid boolean.
        """

        return int(value)


    @staticmethod
    def boolean_get(value):
        """
        Get a boolean value from a string. Raise a ValueError if the string
        is not a valid boolean.
        """

        lower_value = value.lower()

        if lower_value != "true" and lower_value != "false":
            raise ValueError("invalid value for boolean: %s" % lower_value)

        return True if lower_value == "true" else False


    @staticmethod
    def hex_get_string(value, min=None, max=None):
        """
        Check that a string is a valid hexadecimal integer, optionally
        checking if it is within a minimum and maximum length. Returns the
        string if the conditions are satisfied, raises a ValueError otherwise.
        """

        length = len(value)

        if length == 0:
            raise ValueError("empty string not a valid hexadecimal integer")

        if min is not None and length < min:
            raise ValueError("hexadecimal integer too short, minimum %i digits required: %s" % (min, value))

        if max is not None and length > max:
            raise ValueError("hexadecimal integer too long, maximum %i digits required: %s" % (max, value))

        if not re.fullmatch("[0-9A-Fa-f][0-9A-Fa-f]*", value):
            raise ValueError("given string not a valid hexadecimal integer: %s" % value)

        return value


    @staticmethod
    def enum_get(value, enum):
        """
        Check that the given value string is in the list of enumeration string
        values, and return the enumeration value the value string is
        equivalent to. Raise a ValueError if it is not in the list.
        """

        for e in enum:
            if value.lower() == e.lower():
                return e

        raise ValueError("given value %s is not a valid enum, must be one of %s" % (value, str(enum)))


    @staticmethod
    def section_name_get(section_type, section):
        """
        Get the unique name for a configuration section by passing in the
        section type and the raw section data.
        """

        return Util.name_get(re.sub("^%s:" % section_type, '', section))


    @staticmethod
    def name_get(value):
        """
        Check that a string is a valid name, and return it. A name is a string
        that is just one word, without whitespace. Raise a ValueError if the
        string is not a valid name.
        """

        name = value.strip()

        if len(name) == 0:
            raise ValueError("empty string not a valid name")

        if not re.fullmatch("[^\s][^\s]*", value):
            raise ValueError("given string not a valid name (contains whitespace): %s" % name)

        return name


    @staticmethod
    def ip_network_get(value):
        """
        Get an IP network from a string. Raises a ValueError if the string
        is not a valid IP network. Supports both IPv4 and IPv6.
        """

        return ipaddress.ip_network(value)


    @staticmethod
    def ip_network_is_v6(value):
        """
        Returns true if the given IP network is an IPv6 network.
        Supports an integer, string, IPv4Network or IPv6Network.
        Raises a ValueError if the given value is not a valid IP network.
        """

        if isinstance(value, ipaddress.IPv6Network):
            return True
        elif isinstance(value, ipaddress.IPv4Network):
            return False

        return isinstance(ipaddress.ip_network(value), ipaddress.IPv6Network)


    @staticmethod
    def ip_address_get(value):
        """
        Get an IP address from a string. Raises a ValueError if the string
        is not a valid IP address. Supports both IPv4 and IPv6.
        """

        return ipaddress.ip_address(value)


    @staticmethod
    def ip_address_remote(local):
        """
        For a given local_address (either an integer, IPv4Address or
        IPv6Address), return the other end of a two-node linknet
        (/31 for IPv4, /127 for IPv6).
        """

        return ipaddress.ip_address(int(local) ^ 1)


    @staticmethod
    def ip_address_is_v6(value):
        """
        Returns true if the given IP address is an IPv6 address.
        Supports an integer, string, IPv4Address or IPv6Address.
        Raises a ValueError if the given value is not a valid IP address.
        """

        if isinstance(value, ipaddress.IPv6Address):
            return True
        elif isinstance(value, ipaddress.IPv4Address):
            return False

        return isinstance(ipaddress.ip_address(value), ipaddress.IPv6Address)


    @staticmethod
    def netmask_get(value, use_ipv6=False):
        """
        Get a subnet mask from a string. Raises a ValueError if the string
        is not a valid subnet mask. Supports both CIDR and dotted decimal form.
        """

        maxlen = 128 if use_ipv6 else 32

        if re.match("\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}", value):
            if use_ipv6:
                raise ValueError("dotted decimal netmask invalid when use_ipv6 is true, use CIDR instead")

            return Util.netmask_dd_to_cidr(value)

        cidr = int(value)

        if cidr > maxlen or cidr < 0:
            raise ValueError("valid CIDR netmask %i, must be within range 0 < x < 128" % cidr)

        return cidr


    @staticmethod
    def netmask_dd_to_cidr(netmask):
        """
        Convert a netmask in dotted decimal form to the CIDR form.
        """

        i = 0
        integer = 0
        segments = netmask.split('.')

        for index, segment in enumerate(segments):
            seg = int(segment)

            if seg > 255 or seg < 0:
                raise ValueError("invalid dotted decimal netmask %s" % netmask)

            integer += (seg << (24 - (8 * index)))

        for b in bin(integer)[2:]:
            if b == '1':
                i += 1
            else:
                break

        return i


    @staticmethod
    def bird_prefix_get(value):
        """
        Check that a string is a BIRD prefix, and return it. Raise a
        ValueError if the string is not a valid BIRD prefix.

        This method allows the use of prefix patterns that are allowed to be
        used in sets of prefixes in BIRD filters.

        Check the BIRD documentation here for more information on BIRD
        prefixes:

        http://bird.network.cz/?get_doc&f=bird-5.html#ss5.2
        """

        prefix = re.split("/", value)

        # Get the IP address and convert it to an IP address object using
        # Util.ip_address_get, to ensure it is a real IP address.
        try:
            address = Util.ip_address_get(prefix[0])
        except ValueError:
            raise ValueError("given value %s is not a valid BIRD prefix, invalid address segment" % value)

        # Check for a valid netmask in the netmask segment.
        try:
            netmask = Util.netmask_get(re.match("[0-9][0-9]*", prefix[1]).group(), Util.ip_address_is_v6(address))
        except ValueError:
            raise ValueError("given value %s is not a valid BIRD prefix, invalid netmask segment" % value)

        # The interesting part about BIRD prefixes, syntatically, is in the
        # netmask segment, which can not just be CIDR numbers, but can also be
        # special expressions, depending on the range of subnets required.
        #
        # This expression can take the following forms:
        # 10.192.0.0/16+ - match all subprefixes of 10.192.0.0/16
        # 10.192.0.0/16- - match all superprefixes of 10.192.0.0/16
        # 10.192.0.0/16{20,24} - match all subprefixes of 10.192.0.0/16 which
        #                        have a prefix length of between 20 to 24.
        #
        # This part checks that the syntax for those expressions is correct.
        expr = re.sub("^%i" % netmask, "", prefix[1])

        if expr:
            if not re.match("^[+-]$", expr) and re.match("^\{[0-9][0-9]*,[0-9][0-9]*\}$", expr):
                netmasks = re.findall("[0-9][0-9]*", expr)

                for n in netmask:
                    try:
                        netmask = Util.netmask_get(n, Util.ip_address_is_v6(address))
                    except ValueError:
                        raise ValueError("given value %s is not a valid BIRD prefix, invalid netmask %i in expression segment" % (value, n))
            else:
                raise ValueError("given value %s is not a valid BIRD prefix, invalid expression segment" % value)

        # All checks have passed. Return the value unmodified.
        return value


    #
    ## File system helper methods.
    #

    @staticmethod
    def path_my_dir():
        """
        Return the directory containing this script.
        """

        return os.path.dirname(os.path.realpath(sys.argv[0]))


    @staticmethod
    def path_root():
        """
        Return the operating system root directory. System independent.
        """

        return os.path.abspath(os.sep)


    @staticmethod
    def path_search(filename, paths):
        """
        Returns the first instance of a valid filepath, made from the given 
        filename joined with each element from the list of paths. If it doesn't
        find a match, returns the final filepath combination from the list.

        Works with both files and directories, but does not distinguish them.
        """

        for path in paths:
            filepath = os.path.join(path, filename)
            if (os.path.exists(filepath)):
                return filepath

        return filepath


    @staticmethod
    def directory_create(path, mode=None):
        """
        Make the directory tree defined in the given file path, including all
        intermediate directories. If the path already exists and is a 
        directory, does nothing.
        """
        if not os.path.exists(path):
            if mode is not None:
                os.makedirs(path, mode)
            else:
                os.makedirs(path)
        elif not os.path.isdir(path):
            raise Exception("file path at %s already exists, but is not a directory" % path)

    #
    ## Checking helper methods.
    #

    @staticmethod
    def pid_get(pid=None, pid_file=None):
        """
        Checks for the existence of a PID on the running system. If true,
        returns the PID number. If false, returns None.

        Can either use a PID number directly, or take in a PID file and check
        that. If the PID file is not valid or the PID contained inside does 
        not exist, this method deletes that PID file.
        """

        if pid and pid_file:
            raise ValueError("pid and pid_file are mutually exclusive arguments")

        if pid_file is not None:
            if os.path.exists(pid_file):
                with open(pid_file, 'r') as f:
                    pid_file_data = f.read().strip()

                if len(pid_file_data) > 0 and re.match("[0-9][0-9]*", pid_file_data):
                    pid = int(pid_file_data)
                else:
                    # Invalid PID file. Remove it.
                    os.remove(pid_file)
                    return None
            else:
               # PID file doesn't exist.
               return None
        elif pid is None:
            raise ValueError("must specify one of pid or pid_file")

        if pid <= 0:
            if pid_file is not None:
                raise ValueError("invalid PID: %i from file: %s" % (pid, pid_file))
            else:
                raise ValueError("invalid PID: %i" % pid)

        try:
            os.kill(pid, 0)
        except OSError as e:
            # ESRCH = No such process
            if e.errno == errno.ESRCH:
                return None
            # EPERM = Permission denied
            # A process clearly exists if we don't have access to it.
            elif e.errno == errno.EPERM:
                return pid
            # EINVAL = Invalid signal
            # Something went wrong.
            else:
                raise
        # No exception - process exists
        else:
            return pid


    @staticmethod
    def pid_exists(pid=None, pid_file=None):
        """
        Checks for the existence of a PID on the running system.

        This method is a wrapper method for Util.pid_get() for it to return
        a boolean value if the returned PID number is not required. Therefore,
        it follows the same behaviour as Util.pid_get() with respect to
        raising exceptions and handling PID files.
        """

        return True if Util.pid_get(pid, pid_file) is not None else False


def close_overlays(signum, frame):
    """
    Shut down all overlays and IPsec tunnels and clean up any temporary files
    before exiting.
    """

    # Ensure that pyroute2 itself does not shut down due to the caught
    # signal.
    signal.signal(signal.SIGTERM, signal.SIG_IGN)

    # Shut down all overlays.
    daemon.shutdown()

    # Remove the PID lock file.
    os.remove(pid_file)

    # Well, we're done...
    sys.exit(0)


def reload_overlays(signum, frame):
    """
    Stop the OverlayDaemon, reload the configuration, and restart it.
    """

    logging.info("Restarting daemon...")

    daemon.stop()
    daemon.start()

    logging.info("Restarted.")


if __name__ == "__main__":
    # Define the search paths. Search for configuration files in the
    # following locations, in this order:
    # 1. (current working directory)
    # 2. (current working directory)/etc/l3overlay
    # 3. (current working directory)/../etc/l3overlay
    # 4. (executable directory)
    # 5. (executable directory)/etc/l3overlay
    # 6. (executable directory)/../etc/l3overlay
    # 7. /etc/l3overlay
    paths = [
        os.getcwd(),
        os.path.join(os.getcwd(), "etc", "l3overlay"),
        os.path.join(os.getcwd(), "..", "etc", "l3overlay"),
        Util.path_my_dir(),
        os.path.join(Util.path_my_dir(), "etc", "l3overlay"),
        os.path.join(Util.path_my_dir(), "..", "etc", "l3overlay"),
        os.path.join(Util.path_root(), "etc", "l3overlay"),
    ]

    lib_dir = os.path.join(Util.path_root(), "var", "lib", "l3overlay")
    log_dir = os.path.join(Util.path_root(), "var", "log")
    run_dir = os.path.join(Util.path_root(), "var", "run")

    # Use the path list to search for these files and directories.
    template_dir = Util.path_search("templates", paths)

    global_conf = Util.path_search("global.conf", paths)
    overlay_conf_dir = Util.path_search("overlays", paths)

    fwbuilder_script_dir = Util.path_search("fwbuilder_scripts", paths)

    log_file = os.path.join(log_dir, "l3overlay.log")
    pid_file = os.path.join(run_dir, "l3overlayd.pid")

    # Parse optional arguments, and return the final values which will be used
    # in l3overlayd configuration.
    argparser = argparse.ArgumentParser(description="Construct one or more MPLS-like VRF networks using IPsec tunnels and network namespaces.")

    argparser.add_argument(
        '-gc', '--global-conf',
        metavar='FILE',
        type=str,
        default=global_conf,
        help="use FILE as the global configuration file",
    )

    argparser.add_argument(
        '-ocd', '--overlay-conf-dir',
        metavar='DIR',
        type=str,
        default=overlay_conf_dir,
        help="use DIR as the overlay conf search directory",
    )

    argparser.add_argument(
        '-oc', '--overlay-conf',
        metavar='FILE',
        type=str,
        nargs='+',
        default=None,
        help="configure the overlay defined in FILE, disables overlay config directory searching",
    )

    argparser.add_argument(
        '-td', '--template-dir',
        metavar='DIR',
        type=str,
        default=template_dir,
        help="use DIR as the configuration template search directory",
    )

    argparser.add_argument(
        '-fsd', '--fwbuilder-script-dir',
        metavar='DIR',
        type=str,
        default=fwbuilder_script_dir,
        help="use DIR as the fwbuilder script search directory",
    )

    argparser.add_argument(
        '-Ld', '--lib-dir',
        metavar='DIR',
        type=str,
        default=lib_dir,
        help="use DIR as the runtime data directory",
    )

    argparser.add_argument(
        '-lf', '--log-file',
        metavar='FILE',
        type=str,
        default=log_file,
        help="log output to FILE",
    )

    argparser.add_argument(
        '-pf', '--pid-file',
        metavar='FILE',
        type=str,
        default=pid_file,
        help="use FILE as the PID lock file",
    )

    args = argparser.parse_args()

    # Look for an existing l3overlayd PID file lock. If there is one and the
    # PID actually exists, shut down this instance and warn the user. If there
    # is a PID file and it doesn't contain a valid process, remove the PID lock
    # and start anyway.
    old_pid = Util.pid_get(pid_file=args.pid_file)

    if old_pid is not None:
        raise RuntimeError("valid PID lock file at %s, to start a new l3overlayd instance, kill the running l3overlayd instance with the PID %i" % (pid_file, old_pid))

    # Find all available overlay configuration files, and build those overlays.
    overlay_paths = []

    # If specific overlay configuration files are specified on the command
    # use only those. If not, search the overlay configuration directory for
    # overlay configuration files.
    if args.overlay_conf is not None:
        for overlay_path in args.overlay_conf:
            overlay_paths.append(overlay_path)
    else:
        for overlay in os.listdir(args.overlay_conf_dir):
            overlay_path = os.path.join(args.overlay_conf_dir, overlay)
            if os.path.isfile(overlay_path):
                overlay_paths.append(overlay_path)

    # Launch a new OverlayDaemon, which takes in all of the configured data and
    # starts/stops the overlays.
    daemon = OverlayDaemon(
        template_dir=args.template_dir,
        lib_dir=args.lib_dir,
        log_file=args.log_file,
        global_conf=args.global_conf,
        fwbuilder_script_dir=args.fwbuilder_script_dir,
        overlay_paths=overlay_paths,
    )

    # Invoke the shutdown routine when receiving the SIGTERM signal.
    signal.signal(signal.SIGTERM, close_overlays)

    # Invoke the reload routine when receiving the SIGHUP signal.
    signal.signal(signal.SIGHUP, reload_overlays)

    # Save the PID of this daemon to a file. This serves as a lock for
    # l3overlayd, and allows it to be monitored by external processes.
    with open(args.pid_file, 'w') as f:
        f.write("%i\n" % os.getpid())

    os.chmod(pid_file, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH)

    # The daemon is now started. Wait until we receive a signal.
    while True:
        signal.pause()
